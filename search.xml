<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode-day-1</title>
    <url>/2020/04/04/leetcode-day-1/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-1"><a href="#LeetCode-30-days-Challenge-Day-1" class="headerlink" title="LeetCode 30 days Challenge - Day 1"></a>LeetCode 30 days Challenge - Day 1</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h2><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定非空数组，找到单独出现的元素。</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<p>解法：</p>
<p>关键利用异或运算符<code>^</code>，对于异或运算：</p>
<ul>
<li>a ^ a == 0</li>
<li>a ^ 0 == a</li>
<li>a ^ b ^ c = a ^ c ^ b</li>
</ul>
<p>结合题目给出除了目标元素外，其余元素各出现两次，不难想到遍历整个数组，逐个将元素进行异或运算，最后剩下的元素即为目标。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) res ^= n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3283/" target="_blank" rel="noopener">Single Number</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-2</title>
    <url>/2020/04/04/leetcode-day-2/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-2"><a href="#LeetCode-30-days-Challenge-Day-2" class="headerlink" title="LeetCode 30 days Challenge - Day 2"></a>LeetCode 30 days Challenge - Day 2</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Happy-Number"><a href="#Happy-Number" class="headerlink" title="Happy Number"></a>Happy Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">1^2 + 9^2 &#x3D; 82</span><br><span class="line">8^2 + 2^2 &#x3D; 68</span><br><span class="line">6^2 + 8^2 &#x3D; 100</span><br><span class="line">1^2 + 0^2 + 0^2 &#x3D; 1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整数，将该整数每一位平方加和得到新的整数，重复直到整数为1或出现循环。</p>
<p>解法：</p>
<p>快慢指针：遇到出现循环情况的题目，可以考虑快慢指针的方法：</p>
<ul>
<li>快指针：一次走2步（在本题中即进行两次运算）。</li>
<li>慢指针：一次走1步（进行一次运算）。</li>
</ul>
<p>在若干次迭代后，如果存在循环，快慢指针会指向同一值，此时退出循环即可。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_pow</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            tmp += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = n, fast = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = get_pow(slow);</span><br><span class="line">            fast = get_pow(fast);</span><br><span class="line">            fast = get_pow(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        <span class="keyword">return</span> (slow == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3284/" target="_blank" rel="noopener">Happy Number</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-3</title>
    <url>/2020/04/04/leetcode-day-3/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-3"><a href="#LeetCode-30-days-Challenge-Day-3" class="headerlink" title="LeetCode 30 days Challenge - Day 3"></a>LeetCode 30 days Challenge - Day 3</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组，找到其中连续和最大的子数组。</p>
<blockquote>
<p>本题是算法导论原题，可以参考原书，以加深理解。</p>
</blockquote>
<p>解法一（遍历，追踪最大值）：</p>
<p>维护一个遍历res为最终答案，cur记录当前已经积累的值，当cur &lt; 0时，重置cur为0。</p>
<p>初次接触者可能有两个问题：</p>
<ol>
<li><p>为什么cur小于0才重置，而不是cur变小了就重置？</p>
<p>cur变小说明加了一个负数，但“迄今为止”，我们所累加的仍是一个正值。</p>
</li>
<li><p>能保证完备性吗？</p>
<p>能。每次cur的更新意味着一个子数组的结束。不妨考虑：</p>
<p>最坏情况：全是负数的数组，每遍历一个值便更新一次cur，res成功track最大的负数。</p>
<p>最佳情况：全数组非负，直到结束不会更新cur，res成功track整个数组的和和。</p>
<p>其他情况：尽可能地以正数为子数组的第一个元素，遇到负数进行“容忍”，直到该子数组和为负，res成功track所有子数组和中最大的一个。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        cur += i;</span><br><span class="line">        res = max(cur, res);</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解法二（分治法）：</p>
<p>这个方法是《算法导论》中介绍的，对每一个数组：</p>
<ol>
<li>取中点，分成左右两份，数组的最大子数组和可能包括或者不包括中点。</li>
<li>考虑以下情况：<ol>
<li>不包括中点，在左边一份：递归地，对左边一份进行求解。</li>
<li>不包括中点，在右边一份：递归地，对左边一份进行求解。</li>
<li>包括中点：中点加上左边一份的最大尾部和以及右边一份的最大头部和。</li>
</ol>
</li>
<li>计算上述三种情况，取最大即为所求。</li>
</ol>
<p>取题中示例：[-2,1,-3,4,-1,2,1,-5,4]</p>
<p>取中点 -1, 分为：[-2,1,-3,4],-1, [2,1,-5,4]</p>
<ol>
<li>对[-2,1,-3,4]进行求解</li>
<li>对 [2,1,-5,4]进行求解</li>
<li>包括-1，左边最大尾部和：4+(-3)+1 = 2，右边最大头部和：2+1 = 3</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包括中点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crossmid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> l_res = INT_MIN, r_res = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 左边最大尾部和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;=l; i--) &#123;</span><br><span class="line">        cur += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; l_res) l_res = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 右边最大头部和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        cur += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; r_res) r_res = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l_res + r_res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不包括中点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">side</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 求三者最大值</span></span><br><span class="line">    <span class="keyword">return</span> max(max(side(nums, l, mid), side(nums, mid + <span class="number">1</span>, r)),  crossmid(nums, l, mid, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> side(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3285/" target="_blank" rel="noopener">Maximum Subarray</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-4</title>
    <url>/2020/04/06/leetcode-day-4/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-4"><a href="#LeetCode-30-days-Challenge-Day-4" class="headerlink" title="LeetCode 30 days Challenge - Day 4"></a>LeetCode 30 days Challenge - Day 4</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h2><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组，将所有非0元素移到数组的前部，并保持相对顺序不变。</p>
<p>解法：</p>
<p>双指针：遇到对数组中元素进行原地操作(in-place)的时候，双指针往往是很好的方法。</p>
<p>本题可以设计两个指针：</p>
<ul>
<li>i：记录当前处理到的位置，若当前位置为非0元素，则交换移动到前部，是0则跳过。</li>
<li>j：记录下一个交换位置，从左到右增长，保证非0元素全部在数组的前部。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 注意 &amp;&amp; 是会提前截断的，若nums[i] == 0，j不会增长</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;nums.size(); i++) <span class="keyword">if</span> (nums[i] != <span class="number">0</span> &amp;&amp; i != ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3286/" target="_blank" rel="noopener">Move Zeroes</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-5</title>
    <url>/2020/04/06/leetcode-day-5/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-5"><a href="#LeetCode-30-days-Challenge-Day-5" class="headerlink" title="LeetCode 30 days Challenge - Day 5"></a>LeetCode 30 days Challenge - Day 5</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a>Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组，记录着若干天股票的价格，进行任意次买入卖出（买入后必须先卖出再进行下一次买入），求最大利润。</p>
<p>解法：</p>
<p>本题是股票的买卖时机系列的第二题，问题关键在于理解：</p>
<ol>
<li><p>对于多日连续上升的情况，每日都进行一次买入卖出等价于最低日买入、最高日卖出；</p>
<p>在下图中，注意：A + B + C = D</p>
<p><img src="http://yanxuan.nosdn.127.net/70510710f7ef55f3a80d7fa901b23296.png" alt="img2.png"></p>
</li>
<li><p>对于两次连续的谷底、峰值情况，每次都进行买入、卖出会优于只进行一次买入、卖出；</p>
<p>在下图中，注意：A + B &gt; C</p>
<p><img src="http://yanxuan.nosdn.127.net/33235b8621329a12ddcf1acfd135fa3e.png" alt="img1.png"></p>
</li>
</ol>
<p>理解了以上两种情况，就能推导出最佳情况实际上就是逐日进行检查，当每日价格高于前一天时，就能盈利。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;prices.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>]) res += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3287/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-6</title>
    <url>/2020/04/06/leetcode-day-6/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-6"><a href="#LeetCode-30-days-Challenge-Day-6" class="headerlink" title="LeetCode 30 days Challenge - Day 6"></a>LeetCode 30 days Challenge - Day 6</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a>Group Anagrams</h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个字符串数组，将其中由相同字母组成的字符串归类到一起。</p>
<p>解法：</p>
<p>为判断是否由相同字母组成，有两种方法：</p>
<ol>
<li>对每个字符串进行排序，排序后相同的即为同组。</li>
<li>对每个字符串统计字母出现的次数，次数相同的即为同组。</li>
</ol>
<p>本题如果调用<code>sort()</code>函数来实现第一个方法，复杂度则为<code>O(KlogK)</code>级别，但由于字母是有限且连续的，不妨考虑使用桶排序的方案，这样可以将复杂度降为<code>O(K)</code>（K为最长字符串长度）。</p>
<p>第二种方法复杂度同为<code>O(K)</code>，本文采用第一种方法。</p>
<p>在知道如何判断后，考虑如何进行归类，作者使用的是<code>unordered_map</code>哈希结构进行归类，即：</p>
<ol>
<li><p>建立一个由字符串到列表的映射：<code>unordered_map&lt;string, vector&lt;string&gt;&gt; m;</code></p>
</li>
<li><p>对题目给出的数组，遍历之，将每个字符串元素进行桶排序，并且将结果作为映射的键，将原字符串加入该键对应的列表中：<code>for (string s : strs) m[BucketSort(s)].push_back(s);</code></p>
</li>
<li><p>遍历m，将结果加入res即可：<code>for (auto &amp;v : m) res.push_back(v.second);</code></p>
<p>（此处操作可以参考“对unordered_map进行遍历”）</p>
</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">BucketSort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bucket</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) bucket[c - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;bucket.size(); i++) <span class="keyword">while</span>(bucket[i]--) &#123;</span><br><span class="line">        res += <span class="string">'a'</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> s : strs) m[BucketSort(s)].push_back(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : m) res.push_back(v.second);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3288/" target="_blank" rel="noopener">Group Anagrams</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-7</title>
    <url>/2020/04/07/leetcode-day-7/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-7"><a href="#LeetCode-30-days-Challenge-Day-7" class="headerlink" title="LeetCode 30 days Challenge - Day 7"></a>LeetCode 30 days Challenge - Day 7</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Counting-Elements"><a href="#Counting-Elements" class="headerlink" title="Counting Elements"></a>Counting Elements</h2><p>Given an integer array <code>arr</code>, count element <code>x</code> such that <code>x + 1</code> is also in <code>arr</code>.</p>
<p>If there’re duplicates in <code>arr</code>, count them seperately.</p>
<p> <strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 1 and 2 are counted cause 2 and 3 are in arr.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [1,1,3,3,5,5,7,7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: No numbers are counted, cause there&#39;s no 2, 4, 6, or 8 in arr.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [1,3,2,3,5,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 0, 1 and 2 are counted cause 1, 2 and 3 are in arr.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [1,1,2,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Two 1s are counted cause 2 is in arr.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个字符串数组，对任一元素x，如果x+1也在数组中，记一次数。对多个相同元素x，分开计算次数。</p>
<p>解法：</p>
<p>使用<code>unordered_map</code>哈希结构进行计数，即：</p>
<ol>
<li><p>建立一个由映射：<code>unordered_map&lt;int, int&gt; m;</code></p>
</li>
<li><p>对题目给出的数组，遍历之，m的键值代表出现的元素，每个键对应的值记录其出现次数（因为若满足计数条件，相同元素要分开考虑，故此处记录了每个元素出现的次数）。</p>
</li>
<li><p>遍历m，判断并更新res即可：<code>for (auto v : m) if (m.count(v.first + 1)) res += v.second;</code></p>
<p>（此处操作可以参考“对unordered_map进行遍历”）</p>
<p>（注意，此处<code>map.count()</code>不为0即“x+1也在数组中”）</p>
</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) m[i]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : m) <span class="keyword">if</span> (m.count(v.first + <span class="number">1</span>)) res += v.second;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/528/week-1/3289/" target="_blank" rel="noopener">Counting Elements</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-8</title>
    <url>/2020/04/08/leetcode-day-8/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-8"><a href="#LeetCode-30-days-Challenge-Day-8" class="headerlink" title="LeetCode 30 days Challenge - Day 8"></a>LeetCode 30 days Challenge - Day 8</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a>Middle of the Linked List</h2><p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p> <strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure>

<p> <strong>Note:</strong></p>
<ul>
<li>The number of nodes in the given list will be between <code>1</code> and <code>100</code>.</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个非空链表的头指针，返回这个链表在中间位置的结点。</p>
<p>解法：</p>
<p>典型例题，常常使用快慢指针来定位链表中部。</p>
<p>快指针一次步进2个结点，慢指针一次步进1个结点。当快指针到达末尾，慢指针正好到达链表中部。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, * slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3290/" target="_blank" rel="noopener">Middle of the Linked List</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-9</title>
    <url>/2020/04/10/leetcode-day-9/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-9"><a href="#LeetCode-30-days-Challenge-Day-9" class="headerlink" title="LeetCode 30 days Challenge - Day 9"></a>LeetCode 30 days Challenge - Day 9</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Backspace-String-Compare"><a href="#Backspace-String-Compare" class="headerlink" title="Backspace String Compare"></a>Backspace String Compare</h2><p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:</p>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>1 &lt;= T.length &lt;= 200</code></li>
<li><code>S</code> and <code>T</code> only contain lowercase letters and <code>&#39;#&#39;</code> characters.</li>
</ol>
<p><strong>Follow up:</strong></p>
<ul>
<li>Can you solve it in <code>O(N)</code> time and <code>O(1)</code> space?</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定两个字符串，其中“#”号表示一个退格，要求判断处理完退格操作后两个字符串是否相同。</p>
<p>解法：</p>
<p>本题是栈结构的经典应用，以下分析模拟操作的原则：</p>
<ol>
<li>遍历字符串，遇到不为退格“#”的字符，压栈。</li>
<li>遇到退格“#”时：<ol>
<li>若栈为空，忽略（空字符串怎么进行退格依然为空）。</li>
<li>反之，将栈顶元素退栈（相当于退格当前字符串的最后一个字符）。</li>
</ol>
</li>
<li>对两个字符串处理完成后，依次退栈比较：<ol>
<li>遇到不相同的字符，则返回<code>false</code>。</li>
<li>比较到栈空，返回<code>true</code>。</li>
</ol>
</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !s.empty()) s.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) s.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !t.empty()) t.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) t.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() &amp;&amp; !t.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() != t.top()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop(); t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s.empty() &amp;&amp; t.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3291/" target="_blank" rel="noopener">Backspace String Compare</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-10</title>
    <url>/2020/04/10/leetcode-day-10/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-10"><a href="#LeetCode-30-days-Challenge-Day-10" class="headerlink" title="LeetCode 30 days Challenge - Day 10"></a>LeetCode 30 days Challenge - Day 10</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   	--&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      		--&gt; Returns 0.</span><br><span class="line">minStack.getMin();   	--&gt; Returns -2.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个最小栈，包括压栈、退栈、返回最小值等函数。</p>
<p>解法：</p>
<p>最小栈结构为了记录最小值，需要多使用一个栈来记录最小值。</p>
<p>接下来，讨论各个方法如何实现：</p>
<ol>
<li><p>push() 压栈：</p>
<ol>
<li><p>首先，无论如何将数据压入数据栈；</p>
</li>
<li><p>接着进行判断，若最小栈栈顶元素大于或等于压入的数据，将该数据压入最小栈。</p>
<p>（此处注意，等于的情况也要压栈，这样才能避免退栈操作在多个最小值删除。）</p>
</li>
</ol>
</li>
<li><p>pop() 出栈：</p>
<ol>
<li><p>首先，若最小栈栈顶元素等于当前栈顶元素，将最小栈栈顶元素弹出。</p>
<p>（此处注意push操作中第二步的注释。）</p>
</li>
<li><p>将栈顶元素出栈。</p>
</li>
</ol>
</li>
<li><p>top() 访问栈顶元素：调用vector结构的back()方法。</p>
</li>
<li><p>getMin() 访问最小值：调用stack结构的top()方法。</p>
</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ministack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        ministack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ministack.top()) ministack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.back() == ministack.top()) ministack.pop();</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ministack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3292/" target="_blank" rel="noopener">Min Stack</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-11</title>
    <url>/2020/04/11/leetcode-day-11/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-11"><a href="#LeetCode-30-days-Challenge-Day-11" class="headerlink" title="LeetCode 30 days Challenge - Day 11"></a>LeetCode 30 days Challenge - Day 11</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p><strong>Example:</strong><br>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵二叉树，要求找到它的直径。二叉树直径定义为其中距离最远的两个节点之间的距离。</p>
<p>解法：</p>
<p>由题，我们知道直径不一定经过当前树的根结点。</p>
<p>因此，对以当前结点为根结点的（子）树，根据是否经过其根结点，可以分为两种情况，递归思想如下：</p>
<ol>
<li>对于非空结点，计算：<ol>
<li>左子树的深度 + 右子树的深度 = <strong>经过</strong>当前结点的最长距离；</li>
<li>左子树的直径（递归，不经过根结点）；</li>
<li>右子树的直径（递归，不经过根结点）；</li>
</ol>
</li>
<li>对以上三值，取最大值即为以当前结点为根的二叉树的直径。</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(getdepth(root-&gt;left), getdepth(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = getdepth(root-&gt;left) + getdepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> max(cur, max(diameterOfBinaryTree(root-&gt;left), diameterOfBinaryTree(root-&gt;right)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3293/" target="_blank" rel="noopener">Diameter of Binary Tree</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-12</title>
    <url>/2020/04/12/leetcode-day-12/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-12"><a href="#LeetCode-30-days-Challenge-Day-12" class="headerlink" title="LeetCode 30 days Challenge - Day 12"></a>LeetCode 30 days Challenge - Day 12</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Last-Stone-Weight"><a href="#Last-Stone-Weight" class="headerlink" title="Last Stone Weight"></a>Last Stone Weight</h2><p>We have a collection of stones, each stone has a positive integer weight.</p>
<p>Each turn, we choose the two <strong>heaviest</strong> stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are totally destroyed;</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li>
</ul>
<p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整形数组，每个值代表一颗石子的质量。每次选取质量最大的两颗石子（如果存在至少两颗石子），若两颗石子质量相等，则进行下一次选取；否则，将一颗质量为它们的质量差的石子加入数组中。</p>
<p>解法：</p>
<p>简单进行模拟，重点注意每次需要选取质量最大的两颗，而且新加入石子后影响原有顺序，考虑使用大顶堆进行存储，作者采用的是STL中大顶堆实现的优先队列<code>&lt;priority_queue&gt;</code>。</p>
<p>确定了储存结构，模拟操作如下：</p>
<ol>
<li>首先遍历数组，将“石子”加入优先队列。</li>
<li>根据题目要求，当剩余石子为1颗或0颗时，结束循环，否则：<ol>
<li>取队首元素，赋值给y，并将之出队；</li>
<li>再次取队首元素，赋值给x，并将之出队；</li>
<li>由于是优先队列，y &gt;= x，因此只需比较x是否与y相等：<ol>
<li>相等：不进行操作，相当于两颗石子抵消了。</li>
<li>不相等：将质量差值y-x加入优先队列。</li>
</ol>
</li>
</ol>
</li>
<li>最后判断队列是否为空即可，</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : stones) pq.push(i);</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">int</span> x = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (x != y) pq.push(y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.empty() ? <span class="number">0</span> : pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3297/" target="_blank" rel="noopener">Last Stone Weight</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-13</title>
    <url>/2020/04/13/leetcode-day-13/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-13"><a href="#LeetCode-30-days-Challenge-Day-13" class="headerlink" title="LeetCode 30 days Challenge - Day 13"></a>LeetCode 30 days Challenge - Day 13</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a>Contiguous Array</h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只包含0或1的数组，求满足条件（子数组中0和1数量相等）的最长连续子数组的长度。</p>
<p>解法：</p>
<p>本题关键是遍历数组，确保不漏掉符合条件的子数组，并更新最大长度。</p>
<p>这里为了减少空间复杂度，使用哈希结构建立count（初始为0，遇0减1，遇1加1）到pos（count第一次出现的位置）的映射：</p>
<ol>
<li>初始化res为最大长度，count为当前1和0的个数差，负数表示0比1多。</li>
<li>建立映射，初始化<code>m[0] = -1</code>的意义是：无论第一个元素是0还是1，count都将变为非0，因此，count=0首次出现的位置实际上是<code>-1</code>处（不存在，只是虚拟出一个位置，以保证当最长子数组包含第一个元素的时候，能正确计算长度）。</li>
<li>在遍历过程中：<ol>
<li>当<code>m.find(count) == m.end()</code>即新的count值首次出现，记录其位置。</li>
<li>反之，更新res为较大值。</li>
</ol>
</li>
</ol>
<p>以下提供参考图片供读者理解：</p>
<p><img src="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/Figures/535_Contiguous_Array.PNG" alt=""></p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        count += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.find(count) == m.end()) m[count] = i;</span><br><span class="line">        <span class="keyword">else</span> res = max(res, i - m[count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3298/" target="_blank" rel="noopener">Contiguous Array</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-14</title>
    <url>/2020/04/14/leetcode-day-14/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-14"><a href="#LeetCode-30-days-Challenge-Day-14" class="headerlink" title="LeetCode 30 days Challenge - Day 14"></a>LeetCode 30 days Challenge - Day 14</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Perform-String-Shifts"><a href="#Perform-String-Shifts" class="headerlink" title="Perform String Shifts"></a>Perform String Shifts</h2><p>You are given a string <code>s</code> containing lowercase English letters, and a matrix <code>shift</code>, where <code>shift[i] = [direction, amount]</code>:</p>
<ul>
<li><code>direction</code> can be <code>0</code> (for left shift) or <code>1</code> (for right shift). </li>
<li><code>amount</code> is the amount by which string <code>s</code> is to be shifted.</li>
<li>A left shift by 1 means remove the first character of <code>s</code> and append it to the end.</li>
<li>Similarly, a right shift by 1 means remove the last character of <code>s</code> and add it to the beginning.</li>
</ul>
<p>Return the final string after all operations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, shift &#x3D; [[0,1],[1,2]]</span><br><span class="line">Output: &quot;cab&quot;</span><br><span class="line">Explanation: </span><br><span class="line">[0,1] means shift to left by 1. &quot;abc&quot; -&gt; &quot;bca&quot;</span><br><span class="line">[1,2] means shift to right by 2. &quot;bca&quot; -&gt; &quot;cab&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcdefg&quot;, shift &#x3D; [[1,1],[1,1],[0,2],[1,3]]</span><br><span class="line">Output: &quot;efgabcd&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">[1,1] means shift to right by 1. &quot;abcdefg&quot; -&gt; &quot;gabcdef&quot;</span><br><span class="line">[1,1] means shift to right by 1. &quot;gabcdef&quot; -&gt; &quot;fgabcde&quot;</span><br><span class="line">[0,2] means shift to left by 2. &quot;fgabcde&quot; -&gt; &quot;abcdefg&quot;</span><br><span class="line">[1,3] means shift to right by 3. &quot;abcdefg&quot; -&gt; &quot;efgabcd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> only contains lower case English letters.</li>
<li><code>1 &lt;= shift.length &lt;= 100</code></li>
<li><code>shift[i].length == 2</code></li>
<li><code>0 &lt;= shift[i][0] &lt;= 1</code></li>
<li><code>0 &lt;= shift[i][1] &lt;= 100</code></li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个原始字符串以及一个位移指令集合shift，shift数组中，每个元素是一个二元组，依次表示对字符串进行的位移操作方向以及位数，要求返回最后处理完成的字符串。</p>
<p>解法：</p>
<p>本题提示中，说明了在限制条件下，直接暴力模拟也能通过，但这肯定不是我们想要的答案，为了尽可能减少“移动”操作，先来分析移动操作的特点：</p>
<ol>
<li>方向0：向左移动amount个元素，实际上是将<code>前amount个元素移动到字符串尾部</code>。</li>
<li>方向1：向右移动amount个元素，实际上是将<code>后amount个元素移动到字符串头部</code>。</li>
</ol>
<p>两次方向不同、amount相同的移动，将相互抵消：<code>abcd -0,2-&gt; cdab -1,2-&gt; abcd</code>。</p>
<p>由此，推断出最便利的做法是，先遍历shift数组，记录最终需要移动的步数（final_amount），具体措施：</p>
<ol>
<li>遇到方向0，final_amount减去对应amount；</li>
<li>遇到方向1，final_amount加上对应amount；</li>
</ol>
<p>最后，根据final_amount的正负（注意对长度取模，长度为n的字符串移动n次将恢复原状），依据移动操作的特点进行处理即可。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stringShift</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; shift)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> final_amount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : shift) final_amount += v[<span class="number">0</span>] ? v[<span class="number">1</span>] : -v[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (final_amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        final_amount %= s.length();</span><br><span class="line">        res = s.substr(<span class="number">0</span>, s.length() - final_amount);</span><br><span class="line">        res = s.substr(s.length() - final_amount) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        final_amount = (-final_amount) % s.length();</span><br><span class="line">        res = s.substr(final_amount);</span><br><span class="line">        res += s.substr(<span class="number">0</span>, final_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3299/" target="_blank" rel="noopener">Perform String Shifts</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-16</title>
    <url>/2020/04/16/leetcode-day-16/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-16"><a href="#LeetCode-30-days-Challenge-Day-16" class="headerlink" title="LeetCode 30 days Challenge - Day 16"></a>LeetCode 30 days Challenge - Day 16</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Valid-Parenthesis-String"><a href="#Valid-Parenthesis-String" class="headerlink" title="Valid Parenthesis String"></a>Valid Parenthesis String</h2><p>Given a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules:</p>
<ol>
<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
<li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li>
<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
<li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string.</li>
<li>An empty string is also valid.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(*)&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(*))&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The string size will be in the range [1, 100].</li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个包含左右圆括号以及星号的字符串，其中星号可以视为左右圆括号或者空字符串，判断该字符串是否符合规范。</p>
<p>解法：</p>
<p>本题乍一看像栈结构的经典例题，但本题引入了<code>*</code>号的特殊性，带来了一定难度。</p>
<p>首先考虑，<code>*</code>的引入带来的影响：</p>
<ol>
<li>假若视为 <code>(</code>，那么需要一个额外的 <code>)</code> 进行匹配。</li>
<li>假若视为 <code>)</code>，那么能额外匹配一个位置在其之前的 <code>(</code> 。</li>
<li>假若视为空，那么没有影响。</li>
</ol>
<p>由于一个符合规范的序列，<code>(</code>往往先于<code>)</code>出现，因此可以考虑 <code>*</code> 的不同取值，对需要的 <code>)</code> 数量的影响。</p>
<p>假设，最少需要min_num个 <code>)</code>，最多需要max_num个 <code>)</code>，问题转化为 <code>*</code> 的不同取值，对上述两个变量的影响：</p>
<ol>
<li>遇到 <code>(</code>：min_num、max_num都增加1，这是显然的。</li>
<li>遇到 <code>)</code>：<ol>
<li>max_num减少1，这也是显然的；</li>
<li>min_num也减少1，但不少于0（右括号只能匹配其左边的左括号，如果min_num减少成负数，相当于之后的右括号匹配了之前的左括号，是不符合常理的）。</li>
</ol>
</li>
<li>遇到 <code>*</code>：<ol>
<li>因为可以看成一个 <code>(</code>，max_num增加1；</li>
<li>也可以看成一个 <code>)</code>，min_num也减少1，但不少于0（理由同上）。</li>
<li>看成空串则不会造成影响。</li>
</ol>
</li>
</ol>
<p>在遍历过程中，若出现max_num小于0的情况，即出现了一个无法匹配的右括号，直接返回 <code>false</code>。</p>
<p>最后，因为min_num是最少需要的条件，判断min_num是否为0即可。</p>
<p>注：本题较难理解的是min_num在遍历过程中不能小于0的原因：小于0则相当于某一个左括号之后的右括号匹配了该左括号，是不符合常理的，这两个括号就是这种情况“ )( ”。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_num = <span class="number">0</span>, max_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            min_num++;</span><br><span class="line">            max_num++;                    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num--;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3301/" target="_blank" rel="noopener">Valid Parenthesis String</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-17</title>
    <url>/2020/04/17/leetcode-day-17/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-17"><a href="#LeetCode-30-days-Challenge-Day-17" class="headerlink" title="LeetCode 30 days Challenge - Day 17"></a>LeetCode 30 days Challenge - Day 17</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只含有字符<code>0</code>和<code>1</code>的二维数组，其中0代表海洋、1代表陆地，<code>连接在一起</code>的陆地构成一座<code>岛屿</code>，求地图中岛屿的个数。</p>
<p>解法：</p>
<p>典型的DFS或BFS问题，本题中可以直接修改grid值，在访问过陆地(1)之后可以将之修改为海洋(0)，无需额外设立一个访问数组。</p>
<p>具体过程如下：</p>
<ol>
<li>新建一个变量nums记录岛屿数。</li>
<li>遍历整个数组，遇到为<code>陆地</code>的元素时，以该元素位置为起点进行深度优先搜索，确保其所在岛屿所有的陆地都被访问到并且修改为海洋。</li>
</ol>
<p>因为每次访问都保证其所在岛屿所有的陆地都被访问到并且修改为海洋，所以遇到新的陆地时将nums加1。</p>
<p>注：本题所给的grid数组是<code>char 字符型</code>数组！进行判断时候不可以写<code>if (grid[i][j])</code>而要写<code>if (grid[i][j]==&#39;1&#39;)</code>。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;grid.size()<span class="number">-1</span> || y&lt;<span class="number">0</span> || y&gt;grid[<span class="number">0</span>].size()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[x][y]==<span class="string">'1'</span>) &#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) dfs(x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>], grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                nums++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3302/" target="_blank" rel="noopener">Number of Islands</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-19</title>
    <url>/2020/04/20/leetcode-day-19/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-19"><a href="#LeetCode-30-days-Challenge-Day-19" class="headerlink" title="LeetCode 30 days Challenge - Day 19"></a>LeetCode 30 days Challenge - Day 19</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个经过“旋转”的升序排列数组，在其中查找<code>target</code>，若不存在返回<code>-1</code>。</p>
<p>解法：</p>
<p>本题有多种解法，作者选用的是一种比较直观的方法，其他更为“tricky”的题解可参考原题讨论区。</p>
<p>思路大体上分为两步：</p>
<ol>
<li>二分搜索，找到原升序排列数组第一个元素在给定数组中的位置<code>sep</code>。</li>
<li>通过映射，将给定数组的元素位置“映射”到实际位置：<code>true_pos = (pos + sep) % nums.size()</code></li>
<li>在此基础上，进行二分搜索。</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, sep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    sep = l;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mapped_mid = (mid + sep) % nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums[mapped_mid] == target) <span class="keyword">return</span> mapped_mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mapped_mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3304/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-18</title>
    <url>/2020/04/20/leetcode-day-18/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-18"><a href="#LeetCode-30-days-Challenge-Day-18" class="headerlink" title="LeetCode 30 days Challenge - Day 18"></a>LeetCode 30 days Challenge - Day 18</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h2><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个m x n的数组，每个元素代表该位置的路径代价，只能向下或向右移动，计算从左上角到右下角的最小代价路径。</p>
<p>解法：</p>
<p>非常简单的动态规划思想：</p>
<ol>
<li>对每个位置，只能从上方或左边到来。</li>
<li>对第一行、第一列的位置，只能从左边、上方到来。</li>
<li>对其他位置，将路径代价从左到右、从上到下地更新为 <code>该位置代价 + min(上方代价，左边代价)</code> 即可。</li>
</ol>
<p>最后，右下角元素的值即为最小代价路径。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid.back().back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3303/" target="_blank" rel="noopener">Minimum Path Sum</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-20</title>
    <url>/2020/04/20/leetcode-day-20/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-20"><a href="#LeetCode-30-days-Challenge-Day-20" class="headerlink" title="LeetCode 30 days Challenge - Day 20"></a>LeetCode 30 days Challenge - Day 20</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Construct Binary Search Tree from Preorder Traversal"></a>Construct Binary Search Tree from Preorder Traversal</h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p>
<p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt;</code> <code>node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt;</code> <code>node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure>

<img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt="img" style="zoom:50%;" />

<p><strong>Note:</strong> </p>
<ol>
<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
<li>The values of <code>preorder</code> are distinct.</li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个二叉搜索树的前序遍历序列，要求还原该二叉树。</p>
<p>解法：</p>
<p>本题只要了解：</p>
<ol>
<li>二叉搜索树的特性：<ol>
<li>对任意结点，其结点值永远满足（如果存在）：<code>左儿子 &lt; 根 &lt; 右儿子</code>；</li>
<li>由此推出，<code>左子树任意值 &lt; 根 &lt; 右子树任意值</code>；</li>
</ol>
</li>
<li>前序遍历：<code>根 -&gt; 左 -&gt; 右</code> 顺序进行遍历。</li>
</ol>
<p>由此，总结还原的思想是：</p>
<ol>
<li>对当前序列，第一个值是根结点，剩余序列中，比第一个值小的是左子树，剩余为右子树。</li>
<li>递归操作即可，当序列只有一个元素时，直接返回。</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r &amp;&amp; preorder[i] &lt; root-&gt;val) i++;</span><br><span class="line">    root-&gt;left = (i == l + <span class="number">1</span>) ? <span class="literal">NULL</span> : build(preorder, l + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = (i &gt; r) ? <span class="literal">NULL</span> : build(preorder, i, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3305/" target="_blank" rel="noopener">Construct Binary Search Tree from Preorder Traversal</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-21</title>
    <url>/2020/04/21/leetcode-day-21/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-21"><a href="#LeetCode-30-days-Challenge-Day-21" class="headerlink" title="LeetCode 30 days Challenge - Day 21"></a>LeetCode 30 days Challenge - Day 21</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Leftmost-Column-with-at-Least-a-One"><a href="#Leftmost-Column-with-at-Least-a-One" class="headerlink" title="Leftmost Column with at Least a One"></a>Leftmost Column with at Least a One</h2><p><em>(This problem is an <strong>interactive problem</strong>.)</em></p>
<p>A binary matrix means that all elements are <code>0</code> or <code>1</code>. For each <strong>individual</strong> row of the matrix, this row is sorted in non-decreasing order.</p>
<p>Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a <code>1</code> in it. If such index doesn’t exist, return <code>-1</code>.</p>
<p><strong>You can’t access the Binary Matrix directly.</strong> You may only access the matrix using a <code>BinaryMatrix</code> interface:</p>
<ul>
<li><code>BinaryMatrix.get(x, y)</code> returns the element of the matrix at index <code>(x, y)</code> (0-indexed).</li>
<li><code>BinaryMatrix.dimensions()</code> returns a list of 2 elements <code>[n, m]</code>, which means the matrix is <code>n * m</code>.</li>
</ul>
<p>Submissions making more than <code>1000</code> calls to <code>BinaryMatrix.get</code> will be judged <em>Wrong Answer</em>. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p>
<p>For custom testing purposes you’re given the binary matrix <code>mat</code> as input in the following four examples. You will not have access the binary matrix directly. </p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[1,1]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0,0,1],[0,0,1,1],[0,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= mat.length, mat[i].length &lt;= 100</code></li>
<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
<li><code>mat[i]</code> is sorted in a non-decreasing way.</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：本题的解释较为生涩，简单来说：给定一个n x m的、只含有0或1的数组，找到其中含有1的、最左边的列，该数组每一行按照非降序排列。</p>
<p>解法：</p>
<p>暴力搜索复杂度是O(nm)，采用二分降到O(nlogm)。</p>
<p>具体实现思想如下：</p>
<ol>
<li>对每一列，使用变量flag（初始化为0）检测是否含有1：flag大于0则含有，反之不含有。</li>
<li>对每一行，使用二分搜索，且注意每一行中1总在0的右边出现（题示：每一行非降序排列），为找到<code>最左边</code>的列，遵守以下规则：<ol>
<li>若mid列含有1，记录之，并且尝试寻找更左边的一列：<code>r = mid</code>；</li>
<li>若mid列不含有1，则尝试寻找更右边的一列：<code>l = mid + 1</code>；</li>
</ol>
</li>
</ol>
<p>最后，当<code>l == r</code>退出时，检测res是否为-1（初始化值），若仍为-1，则需要对第 <code>l</code> 列再次进行检测。</p>
<p>注：解释一下为什么只有为-1时需要检测：</p>
<ol>
<li>退出时若res已经不为-1，则是通过规则1达到退出条件，说明正在尝试寻找“更左边”的一列，然而此时已经不存在更左边的合格列了，则无需检测。</li>
<li>若仍为-1，说明正在通过规则2尝试寻找合法列，退出循环后需要进行检测看看最后是否找到。</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = binaryMatrix.dimensions()[<span class="number">0</span>], m = binaryMatrix.dimensions()[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>, res = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, mid);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;res = mid; r = mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? l : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306/" target="_blank" rel="noopener">Leftmost Column with at Least a One</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-22</title>
    <url>/2020/04/22/leetcode-day-22/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-22"><a href="#LeetCode-30-days-Challenge-Day-22" class="headerlink" title="LeetCode 30 days Challenge - Day 22"></a>LeetCode 30 days Challenge - Day 22</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a>Subarray Sum Equals K</h2><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The length of the array is in range [1, 20,000].</li>
<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组、一个整数k，求数组中所有和为k的子数组个数。</p>
<p>解法：</p>
<p><em>本题暴力解法、求累计值再遍历的O(n^2^)解法较简单，可以参考原题讨论区，本文主要就介绍O(n)的做法。</em></p>
<p>首先考虑该式：<code>前 i 项和 - 前 j 项和 = i 到 j 的和（i &gt; j）</code>；实际任务即：找到所有满足<code>i 到 j 的和</code>等于<code>k</code>的子数组。</p>
<p>根据该思想，在遍历数组<code>nums</code>的过程中，假设当前位置为<code>i</code>，执行<code>nums[i] += nums[i-1]</code>，迭代来看，<code>nums[i]</code>即为<code>前 i 项和</code>。根据等式性质，只要检测<code>nums[i] - k</code>（即<code>nums[j]</code>）是否在之前出现过，就能确定是否存在子数组。</p>
<p>我们使用一个哈希结构来存储 <code>前 i 项和</code>出现的次数，这样就能在一次遍历的过程中，O(1)时间找到答案。</p>
<p>具体操作如下：</p>
<ol>
<li>进入循环，遍历nums；</li>
<li>当累加后，如果当前值为k，说明从0到该位置的子数组满足条件，结果加1；</li>
<li>在哈希表中查找 nums[i] - k：<code>m.find(nums[i] - k) != m.end()</code>，unordered_map的find方法，当键不存在时，返回位置end()；</li>
<li>将当前nums[i]的值存入哈希表中，若已存在则加1：m[key]保存key出现的次数。</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">        res += nums[i] == k;</span><br><span class="line">        <span class="keyword">if</span> (m.find(nums[i] - k) != m.end()) res += m[nums[i] - k];</span><br><span class="line">        m[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3307/" target="_blank" rel="noopener">Subarray Sum Equals K</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-23</title>
    <url>/2020/04/23/leetcode-day-23/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-23"><a href="#LeetCode-30-days-Challenge-Day-23" class="headerlink" title="LeetCode 30 days Challenge - Day 23"></a>LeetCode 30 days Challenge - Day 23</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [5,7]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整数m和一个整数n，m小于等于n，求将从n到m这些数的按位与的结果。</p>
<p>解法：</p>
<p>本题乍一看可以直接模拟，但是由于数字范围很大，模拟的开销太高，会TLE。</p>
<p>这里介绍一种做法：</p>
<p>首先观察：</p>
<p>0    0 0 0 0</p>
<p>1    0 0 0 1</p>
<p>2    0 0 1 0</p>
<p>3    0 0 1 1</p>
<p>4    0 1 0 0</p>
<p>5    0 1 0 1</p>
<p>6    0 1 1 0</p>
<p>7    0 1 1 1</p>
<p>8    1 0 0 0</p>
<p>这次0 - 8数字的二进制表示，可以看到，从右往左<code>第 i 位</code>的规律是：从0开始，0重复 2^i-1^ 次，1重复 2^i-1^ 次，一直这样循环下去。</p>
<p>再考虑与运算的特点：所有参加运算的数字中，出现了一个0，则结果就一定为0，这是显然的。</p>
<p>那么，问题转化为：<code>如何判断m到n之间，每个比特位是否出现0？</code></p>
<ol>
<li>从右往左，先确定当前<code>循环节长度的一半</code>：<code>power = 1</code>(2^0^)，每向左一位，<code>power *= 2</code>，注意不要爆INT。</li>
<li>确定循环节长度的一半后，对数字 k，<code>k / power</code>(2^i^)有以下情况：<ol>
<li>为奇数：那么k的二进制表示、从右往左第 i 位为 1；</li>
<li>为偶数：那么k的二进制表示、从右往左第 i 位为 0；</li>
</ol>
</li>
<li>有了以上的结论后，结合题目给出的m、n考虑，对第 i 位，m / power以及n / power 有以下情况：<ol>
<li>奇 + 奇，且为同一个奇数：m到n，第 i 位，全是 1，该位置需要记入结果，<code>res += power</code>；</li>
<li>奇 + 奇，但为不同的奇数：m到n，第 i 位，两个1中间存在0，该位置不需要记入结果；</li>
<li>奇 + 偶 / 偶 + 奇 /偶 + 偶：出现偶数，第 i 位存在 0，该位置不需要记入结果；</li>
</ol>
</li>
</ol>
<p>注：</p>
<ol>
<li>注意while循环退出条件：当m小于power即可退出，因为m小于power，那么m表示为二进制表示后，power对应的那一位为0，不需要计入结果了。</li>
<li>注意power倍增不能爆INT，当power为2^30^次幂的时候，需要检测判断，并赋值为INT_MAX，直接乘2会导致爆INT：INT_MAX = 2^31^ - 1 &lt; 2^31^</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (power &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m / power) % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; (m / power) == (n / power)) &#123;</span><br><span class="line">                res += power;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (power == INT_MAX/<span class="number">2</span> + <span class="number">1</span>) power = INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> power *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3308/" target="_blank" rel="noopener">Bitwise AND of Numbers Range</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-24</title>
    <url>/2020/04/25/leetcode-day-24/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-24"><a href="#LeetCode-30-days-Challenge-Day-24" class="headerlink" title="LeetCode 30 days Challenge - Day 24"></a>LeetCode 30 days Challenge - Day 24</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：要求设计一个缓存机制，并实现访问get操作、put插入操作。</p>
<ol>
<li><code>get操作</code>：当元素不存在，返回<code>-1</code>。</li>
<li><code>put操作</code>：当占满空间后再次插入内容时，将最近最少使用的元素删去，替换之。</li>
</ol>
<p>解法：</p>
<p>本题的朴素解法较简单，本文介绍一种O(1)访存的设计：双向链表（带头尾指针）+ 哈希结构（键值-&gt;链表结点）</p>
<p>先分析，该设计如何实现O(1)的访存要求：</p>
<ol>
<li><p>get操作：按照键值访问哈希表是O(1)的，找到哈希表对应的元素后，访问结点的val元素即可。</p>
</li>
<li><p>put操作：</p>
<ol>
<li><p>检测是否已存在该键值（unordered_map的find函数实现如下，是O(1)的）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</span><br><span class="line">	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;::</span><br><span class="line">    find(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span></span><br><span class="line">    -&gt; const_iterator</span><br><span class="line">    &#123;</span><br><span class="line">      __hash_code __code = <span class="keyword">this</span>-&gt;_M_hash_code(__k);</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> __n = _M_bucket_index(__k, __code);</span><br><span class="line">      __node_type* __p = _M_find_node(__n, __k, __code);</span><br><span class="line">      <span class="keyword">return</span> __p ? const_iterator(__p) : end();</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测缓存是否已满是O(1)的。</p>
</li>
<li><p>在哈希表中删除（erase）是O(1)的。</p>
</li>
<li><p>在链表尾部删除结点、头部插入结点也是O(1)的。</p>
</li>
</ol>
</li>
</ol>
<p>综上，能保证是O(1)的访存。</p>
<p>接下来介绍实现中需要注意的几点：</p>
<ol>
<li>删除LRU数据时依据是：通过双向链表尾结点的前一个结点，确定哈希表应该删除哪一表项。因此，链表结点除了记录数据之外，还要记录键值。<code>m.erase(m.find(rear-&gt;pre-&gt;key)); // 哈希表的删除语句</code></li>
<li>put操作需要进行的判断有三种情况，勿遗漏：<ol>
<li>缓存已满，插入的键值不存在：删除LRU，在头部插入新键值对（结点）。</li>
<li>插入的键值已存在，此时不需考虑缓存是否已满：查找键值对应数据，更新为新值，并移动到头部。</li>
<li>插入的键值不存在，缓存未满的情况：直接在同步插入新键值对（结点）。</li>
</ol>
</li>
</ol>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双向链表结点定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : key(x), val(y), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cap;	<span class="comment">// 容量</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);	<span class="comment">// 头指针</span></span><br><span class="line">    ListNode* rear =  <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);	<span class="comment">// 尾指针</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;	<span class="comment">// 哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动结点到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move2front</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除LRU</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeLRU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = rear-&gt;pre;</span><br><span class="line">        rear-&gt;pre = tmp-&gt;pre;</span><br><span class="line">        tmp-&gt;pre-&gt;next = rear;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在头部插入新结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = <span class="keyword">new</span> ListNode(key, val);</span><br><span class="line">        tmp-&gt;next = head-&gt;next;</span><br><span class="line">        tmp-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = tmp;</span><br><span class="line">        head-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 访问操作</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">            <span class="keyword">return</span> m[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put 插入键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) == m.end() &amp;&amp; m.size() == cap) &#123;</span><br><span class="line">            m.erase(m.find(rear-&gt;pre-&gt;key));</span><br><span class="line">            removeLRU();</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            m[key]-&gt;val = value;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3309/" target="_blank" rel="noopener">LRU Cache</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-25</title>
    <url>/2020/04/25/leetcode-day-25/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-25"><a href="#LeetCode-30-days-Challenge-Day-25" class="headerlink" title="LeetCode 30 days Challenge - Day 25"></a>LeetCode 30 days Challenge - Day 25</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定只含有非负元素的整型数组，从第一个位置开始，每一个元素值代表在该位置能够跳跃到达的最远距离，判断给定的数组能否依照规则到达最后一个位置。</p>
<p>解法：</p>
<p>本题采用双指针思想，尽可能优化了时间复杂度。</p>
<p>以下简述双指针的方案：</p>
<ol>
<li>首先，对于<code>左指针 l</code>，<code>右指针 r</code>，每次进入while循环体，我们将检测两个指针之间的所有位置，看看这些位置有没有可能跳转到最后一个位置，若能，则返回<code>true</code>。</li>
<li>假设不能，那么我们需要更新两个指针，且<code>尽可能使两个指针移动的足够快</code>：<ol>
<li><code>l = r + 1</code>：左指针的更新发生在本次检测之后，我们期望<code>不要进行重复的检测来优化时间</code>，那么左指针将更新为<code>本次检测的最后一个位置的后一个位置</code>。</li>
<li><code>r = nextr</code>：在检测两个指针中间位置过程中，将能到达的最远位置，更新给<code>nextr</code>，<code>nextr</code>用于记录下一次while循环应该检测的右指针位置。</li>
</ol>
</li>
</ol>
<p>注：参考上方第二个示例的情况，若对while循环不加退出条件，l、r将会一直为(3, 3)；为避免陷入死循环，检测到两次循环的左右指针全部未改变时，提前退出。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n = nums.size() - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, nextr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nextr = nums[r] ? r + <span class="number">1</span> : r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> nextr = max(nextr, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        l = r+<span class="number">1</span>;</span><br><span class="line">        r = nextr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (l != r+<span class="number">1</span> || r != nextr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3310/" target="_blank" rel="noopener">Jump Game</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-27</title>
    <url>/2020/04/27/leetcode-day-27/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-27"><a href="#LeetCode-30-days-Challenge-Day-27" class="headerlink" title="LeetCode 30 days Challenge - Day 27"></a>LeetCode 30 days Challenge - Day 27</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个值为0或1的二维数组，求其中由1组成的、面积最大的正方形面积。</p>
<p>解法：</p>
<p>本题使用动态规划思想，其中<code>dp[i][j]</code>记录以i、j为右下角坐标的正方形的最大边长，从左往右，从上往下遍历一遍数组，并记录其中出现过的最大边长，返回结果即为最大边长的平方。</p>
<p>dp数组按照以下规则进行更新：</p>
<ol>
<li>对i，j：满足以i、j为右下角坐标的正方形边长范围是<code>1 - (min(i, j) + 1)</code>，这些边长的正方形中只要有一个元素不为1，则不能加入结果。</li>
<li>根据动态规划的思想：当前状态只与其上一个状态有关，即对于上述以i、j为右下角坐标的正方形，边长为 <code>(min(i, j) + 1)</code>的正方形就是<code>当前状态</code>，因此需要考虑其<code>上一个状态</code>即边长为<code>min(i, j)</code>的正方形是如何影响当前状态的。</li>
<li>不难发现，边长为 <code>(min(i, j) + 1)</code>的正方形除去最右下角元素后含有三个边长为<code>min(i, j)</code>的正方形（分别是去除最右列、最下行，去除最右列、最上行，去除最左列、最下行三种情况），当且仅当这三个正方形都全是1、且位置(i, j)也是1时，<code>dp[i][j]</code>取值为<code>(min(i, j) + 1)</code>；</li>
<li>综上，规则为：<code>dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1</code></li>
</ol>
<p>下图展示了遍历过程中三种情况：</p>
<p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt=""></p>
<p>注：最终求的是面积，注意返回最大边长的平方。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3312/" target="_blank" rel="noopener">Maximal Square</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-26</title>
    <url>/2020/04/27/leetcode-day-26/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-26"><a href="#LeetCode-30-days-Challenge-Day-26" class="headerlink" title="LeetCode 30 days Challenge - Day 26"></a>LeetCode 30 days Challenge - Day 26</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h2><p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p>
<p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p>
<p>If there is no common subsequence, return 0. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= text1.length &lt;= 1000</code></li>
<li><code>1 &lt;= text2.length &lt;= 1000</code></li>
<li>The input strings consist of lowercase English characters only.</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定两个字符串，求其中最长公共子串的长度。</p>
<p>解法：</p>
<p>本题需要注意区分子序列、子串：subsequence是子序列，子序列中各元素不需要连续，substring是子串，子串中每个元素必须是连续的。</p>
<p>本题是经典的动态规划题，维护一个二维动态规划数组dp，其中：</p>
<ol>
<li><code>i：1 - text1.length()</code>；<code>j：1 - text2.length()</code>；</li>
<li><code>dp[i][j]</code>：text1[0:i-1]子串以及text2[0:j-1]子串之间最长公共子串的长度。</li>
<li>更新规则（对text1的每一个位置 - i-1，遍历text2所有的位置 - j-1）：<ol>
<li>当<code>text1[i-1] == text2[j-1]</code>：<code>dp[i][j] = dp[i-1][j-1] + 1;</code></li>
<li>否则： <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</code></li>
</ol>
</li>
</ol>
<p>最终结果即为 <code>dp[text1.length()][text2.length()]</code>。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(text1.length()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(text2.length()+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3311/" target="_blank" rel="noopener">Longest Common Subsequence</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-28</title>
    <url>/2020/04/28/leetcode-day-28/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-28"><a href="#LeetCode-30-days-Challenge-Day-28" class="headerlink" title="LeetCode 30 days Challenge - Day 28"></a>LeetCode 30 days Challenge - Day 28</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="First-Unique-Number"><a href="#First-Unique-Number" class="headerlink" title="First Unique Number"></a>First Unique Number</h2><p>You have a queue of integers, you need to retrieve the first unique integer in the queue.</p>
<p>Implement the <code>FirstUnique</code> class:</p>
<ul>
<li><code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.</li>
<li><code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.</li>
<li><code>void add(int value)</code> insert value to the queue. </li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[2,3,5]],[],[5],[],[2],[],[3],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,2,null,2,null,3,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([2,3,5]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(5);            &#x2F;&#x2F; the queue is now [2,3,5,5]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(2);            &#x2F;&#x2F; the queue is now [2,3,5,5,2]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 3</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [2,3,5,5,2,3]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,-1,null,null,null,null,null,17]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([7,7,7,7,7,7]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3]</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7]</span><br><span class="line">firstUnique.add(17);           &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7,17]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 17</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[809]],[],[809],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,809,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([809]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 809</span><br><span class="line">firstUnique.add(809);          &#x2F;&#x2F; the queue is now [809,809]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= value &lt;= 10^8</code></li>
<li>At most <code>50000</code> calls will be made to <code>showFirstUnique</code> and <code>add</code>.</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个能够返回<code>第一个唯一元素</code>的队列。要求实现：1.返回<code>第一个唯一元素</code>的功能；2. 添加一个新元素。</p>
<p>解法：</p>
<p>本题重点需要理清，两个功能在各种不同的情况下，应该如何工作：</p>
<ol>
<li><code>showFirstUnique()</code>：<ol>
<li>当队列为空，或没有唯一元素，返回 <code>-1</code>；</li>
<li>当队列存在唯一元素，返回第一个唯一的<code>元素值</code>。</li>
</ol>
</li>
<li><code>add(int value)</code>：<ol>
<li>当队列不存在该元素，那么<code>加入队列</code>。</li>
<li>当队列存在该元素，那么将<code>原来的元素从队列中移除</code>，并且<code>以后不能在加入该元素</code>。</li>
</ol>
</li>
</ol>
<p>到这里，逻辑思路就整理完毕，接下来考虑数据结构使用问题。</p>
<ol>
<li>为了<code>常量时间</code>访存，使用存在头尾指针的双向链表来存储<code>唯一的元素</code>：<ol>
<li>每个元素初次出现都加入该链表，当重复的元素出现时，从该表移除，且不再加入该表，所以说存储的是“唯一的”元素。</li>
<li>第一个唯一元素即为第一个链表元素：<code>head-&gt;next == rear ? -1 : head-&gt;next-&gt;val</code>；此处注意对链表是否为空的判断。</li>
<li>当通过add加入新元素：新元素通过<code>尾插法</code>加入链表，不会打乱原有的相对顺序。</li>
<li>当出现重复元素，删除某一节点时：参见代码<code>removeNode(ListNode* node)</code>处。</li>
</ol>
</li>
<li>为了<code>常量时间</code>判断元素存在，建立从value到链表指针的映射<code>unordered_map&lt;int, ListNode*&gt; m</code>：<ol>
<li>添加一个元素时，通过 <code>m.find(value) != m.end()</code>判断元素是否存在。</li>
<li>若不存在，新建链表结点、插入链表中、将指针赋给<code>m[value]</code>，这样可以通过常量时间访问到该value对应的链表结点。</li>
<li>为了实现“<code>以后不能在加入该元素</code>”的功能，当出现重复元素时，从链表中删除原元素后，将<code>m[value]</code>指向<code>NULL</code>，未来再次遇到该元素时就不会再次进行删除元素操作（已经不存在该元素，删除操作会造成错误）。</li>
</ol>
</li>
</ol>
<p>本题值得细品，勿只读解法，务必参考代码，整理清楚逻辑。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstUnique</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) : val(x), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        rear-&gt;pre-&gt;next = node;</span><br><span class="line">        node-&gt;pre = rear-&gt;pre;</span><br><span class="line">        node-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = node;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* rear = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;</span><br><span class="line"></span><br><span class="line">    FirstUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showFirstUnique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == rear ? <span class="number">-1</span> : head-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(value) != m.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[value] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                removeNode(m[value]);</span><br><span class="line">                m[value] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(value) == m.end()) &#123;</span><br><span class="line">            ListNode* node = addNode(value);</span><br><span class="line">            m[value] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/" target="_blank" rel="noopener">First Unique Number</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch-tutorial-word-embedding</title>
    <url>/2020/04/29/Pytorch-tutorial-word-embedding/</url>
    <content><![CDATA[<blockquote>
<p>原文传送门：<a href="https://pytorch.org/tutorials/beginner/nlp/word_embeddings_tutorial.html" target="_blank" rel="noopener">WORD EMBEDDINGS: ENCODING LEXICAL SEMANTICS</a></p>
</blockquote>
<h1 id="译-Pytorch-官方教程-词嵌入：编码词语与语义"><a href="#译-Pytorch-官方教程-词嵌入：编码词语与语义" class="headerlink" title="[译] Pytorch 官方教程 词嵌入：编码词语与语义"></a>[译] Pytorch 官方教程 词嵌入：编码词语与语义</h1><blockquote>
<p>WORD EMBEDDINGS: ENCODING LEXICAL SEMANTICS</p>
</blockquote>
<p>词嵌入指的是：将用户词表中每一个单词与一个实数对应，并嵌入到一个<a href="https://stackoverflow.com/questions/31522893/sparse-vector-vs-dense-vector" target="_blank" rel="noopener">密度向量</a>中。在自然语言处理中，绝大多数情况研究的特征都是单词。然而，应该怎样在计算机中表示一个单词呢？一种方案是存储单词每个字母对应的ascii码，但这只能让我们知道我们存储的这个单词由哪些字母组成，并不能表达这个单词具体的含义（或许能从词缀推断出词性、从大小写推断出属性，但这远远不够）。而且，凭什么可以将这些表示组合在一起？</p>
<p>我们设计的神经网络往往是$|V|$（词汇表的长度）维的，但是却需要从神经网络中得到低维、密集的输出（譬如需要预测的标签只有几个），我们要怎样从将数据从高维空间转移到低维空间呢？</p>
<p>不妨试试用<a href="https://blog.csdn.net/chary8088/article/details/79032223" target="_blank" rel="noopener">one-hot编码</a>来代替ascii码？即，对某个单词w，按以下方式表示：<br>$$<br>\overbrace{\left[ 0, 0, \dots, 1, \dots, 0, 0 \right]}^\text{|V| elements}<br>$$<br>其中，每个单词都只含有1个’1’（剩余为0），而且每个单词的’1’的位置都不同。</p>
<p>上述方法不仅占用了巨量的空间，而且还有一个致命的弊端：这种方法将每个单词标记为独立的实体，认为他们之间没有关联。</p>
<p>我们真正想要的，是使用一些标记方法，来<code>标记词与词之间的相似关系</code>。难以理解？且看以下示例。</p>
<p>假设我们正在建立一个语言模型，假设有以下语句：</p>
<ul>
<li>The mathematician ran to the store.</li>
<li>The physicist ran to the store.</li>
<li>The mathematician solved the open problem.</li>
</ul>
<p>在我们的训练数据中。</p>
<p>现在，我们读取到了一个在训练数据中从未见过的语句：</p>
<ul>
<li>The physicist solved the open problem.</li>
</ul>
<p>我们的语言模型在这一语句上也许能表现不错，但如果能够将以下两个事实也考虑进去，相信将会更好：</p>
<ul>
<li>我们在训练语句中，发现mathematician以及physicist在句中是相同的成分，换句话说，他们有着一定的语义关系。</li>
<li>在新语句中，虽然看到的是physicist，但是我们认为mathematician在句中的成分是和physicist一致的。</li>
</ul>
<p>由此，推断出physicist在新语句中的拟合度很好。</p>
<p>这正是上述<code>标记词与词之间的相似关系</code>的真实含义：相似关系指的是语义上的相似，而不是指字符拼写上相似。</p>
<p>这一技术在训练数据和未知的数据之间建立了联系，能有效克服语言学（文本）数据的稀疏性。当然，这基于一个基本假设：出现在相似上下文之中的单词在语义上相关。这也被称为<a href="https://en.wikipedia.org/wiki/Distributional_semantics" target="_blank" rel="noopener">分布式假设</a>。</p>
<hr>
<h2 id="稠密词嵌入"><a href="#稠密词嵌入" class="headerlink" title="稠密词嵌入"></a>稠密词嵌入</h2><blockquote>
<p>Getting Dense Word Embeddings</p>
</blockquote>
<p>如何获得词嵌入呢？换句话说，我们具体要如何将语义的相似性进行编码？</p>
<p>或许我们可以考虑一些语义属性。例如，<code>is able to run</code>属性：mathematicians 和 physicists 都能 “run”，因此二者在该属性上都标记为高分。再考虑一些属性，并且为这些属性对不同的单词进行打分。</p>
<p>如果将每个属性视为一个维度，那么我们能将每个单词表示为一个向量（词嵌入向量）：<br>$$<br>q_\text{mathematician} = \left[ \overbrace{2.3}^\text{can run}, \overbrace{9.4}^\text{likes coffee}, \overbrace{-5.5}^\text{majored in Physics}, \dots \right]<br>$$</p>
<p>$$<br>q_\text{physicist} = \left[ \overbrace{2.5}^\text{can run},<br>\overbrace{9.1}^\text{likes coffee}, \overbrace{6.4}^\text{majored in Physics}, \dots \right]<br>$$</p>
<p>由此，我们得到了度量单词相似性的一个方法：<br>$$<br>\text{Similarity}(\text{physicist}, \text{mathematician}) = q_\text{physicist} \cdot q_\text{mathematician}<br>$$<br>按照向量长度标准化后：<br>$$<br>\text{Similarity}(\text{physicist}, \text{mathematician}) = \frac{q_\text{physicist} \cdot q_\text{mathematician}}<br>{| q_\text{physicist} | | q_\text{mathematician} |} = \cos (\phi)<br>$$<br>其中，$\phi$ 标记两个向量的夹角。这样一来，极度相似的单词（他们的词嵌入向量指向几乎相同的方向）的similarity值为1，极度不相似的单词（他们的词嵌入向量指向几乎相反的方向）的similarity值为-1，</p>
<p>现在回顾one-hot编码，可以将其看成词嵌入向量的一种特殊情况，每个单词的相似度为0，且为每个单词单独分配了一个唯一的语义属性。</p>
<p>同时，我们称新定义的向量是稠密的，也就是说这些向量的元素绝大多数不为0。</p>
<p>然而， 这些新定义的向量有一个大问题：我们能为相似性的度量，定义成千上万个不同的语义属性，那么到底如何为不同的属性打分呢？</p>
<p>深度学习的核心思想是使计算机利用神经网络自动学习特征的含义，而不是需要程序员来手动设计。那么，为何不将词嵌入作为模型参数，让词嵌入在训练过程中自动更新迭代呢？</p>
<p>这正是我们要做的：我们将设计一些神经网络在原则上能够进行学习的<code>潜在语义属性</code>。注意，词嵌入可能是难以解释甚至不可解释的。也就是说，虽然在上述例子中，我们能通过手工标记的方法知道mathematicians以及physicists都喜欢咖啡，但是如果我们用一个神经网络去学习这些词嵌入，并且发现mathematicians以及physicists的词嵌入在某个维度上都有着很高的分数，我们也不清楚这个维度到底意味着什么（即不明该维度的语义）。他们在潜在语义属性上相似，但这对我们来说不可解释。</p>
<p>总而言之，<strong>词嵌入表示的是单词语义，能够高效地编码与手头任务相关的语义信息</strong>。除了语义信息，还能够嵌入其他的信息：词性标签、语义分析树、甚至任意信息！特征嵌入的思想是这一领域的核心。</p>
<hr>
<h2 id="Pytorch中的词嵌入"><a href="#Pytorch中的词嵌入" class="headerlink" title="Pytorch中的词嵌入"></a>Pytorch中的词嵌入</h2><blockquote>
<p>Word Embeddings in Pytorch</p>
</blockquote>
<p>（部分内容已省略）</p>
<p>在定义词嵌入时，我们需要为每一个单词定义一个索引，这些索引将会成为一个查询表中的键值。</p>
<p>换句话说，词嵌入将被存储为一个$|V|×D $的矩阵，D为词嵌入的维度。我们为<code>某一单词定义的索引i即表示该单词在词嵌入矩阵中的第i行</code>。下文中，从单词到其索引的映射将被命名为 <code>word_to_ix</code>。</p>
<p>Pytorch中为词嵌入提供服务的模块是 <code>torch.nn.Embedding</code>，<code>torch.nn.Embedding</code>接受两个参数：<code>词汇表长度、词嵌入维度</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Guthrie</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word_to_ix = &#123;<span class="string">"hello"</span>: <span class="number">0</span>, <span class="string">"world"</span>: <span class="number">1</span>&#125;</span><br><span class="line">embeds = nn.Embedding(<span class="number">2</span>, <span class="number">5</span>)  <span class="comment"># 2 words in vocab, 5 dimensional embeddings（词汇表长度为2，嵌入维度为5）</span></span><br><span class="line">lookup_tensor = torch.tensor([word_to_ix[<span class="string">"hello"</span>]], dtype=torch.long)</span><br><span class="line">hello_embed = embeds(lookup_tensor)</span><br><span class="line">print(hello_embed)</span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<blockquote>
<p>tensor([[ 0.6614,  0.2669,  0.0617,  0.6213, -0.4519]],<br>    grad_fn=<EmbeddingBackward>)</p>
</blockquote>
<hr>
<h2 id="示例：N-Gram-语言模型"><a href="#示例：N-Gram-语言模型" class="headerlink" title="示例：N-Gram 语言模型"></a>示例：N-Gram 语言模型</h2><blockquote>
<p>An Example: N-Gram Language Modeling</p>
</blockquote>
<p>回顾n-gram模型，给定一个单词序列 w，我们需要计算：<br>$$<br>P(w_i | w_{i-1}, w_{i-2}, \dots, w_{i-n+1} )<br>$$<br>其中 $w_i$ 是w中的第i个单词。</p>
<p>在本例中，我们将计算一些训练样本的<code>损失函数</code>然后使用<code>反向传播来更新模型参数</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONTEXT_SIZE = <span class="number">2</span></span><br><span class="line">EMBEDDING_DIM = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We will use Shakespeare Sonnet 2</span></span><br><span class="line"><span class="comment"># 使用莎士比亚的《十四行诗》2</span></span><br><span class="line">test_sentence = <span class="string">"""When forty winters shall besiege thy brow,</span></span><br><span class="line"><span class="string">And dig deep trenches in thy beauty's field,</span></span><br><span class="line"><span class="string">Thy youth's proud livery so gazed on now,</span></span><br><span class="line"><span class="string">Will be a totter'd weed of small worth held:</span></span><br><span class="line"><span class="string">Then being asked, where all thy beauty lies,</span></span><br><span class="line"><span class="string">Where all the treasure of thy lusty days;</span></span><br><span class="line"><span class="string">To say, within thine own deep sunken eyes,</span></span><br><span class="line"><span class="string">Were an all-eating shame, and thriftless praise.</span></span><br><span class="line"><span class="string">How much more praise deserv'd thy beauty's use,</span></span><br><span class="line"><span class="string">If thou couldst answer 'This fair child of mine</span></span><br><span class="line"><span class="string">Shall sum my count, and make my old excuse,'</span></span><br><span class="line"><span class="string">Proving his beauty by succession thine!</span></span><br><span class="line"><span class="string">This were to be new made when thou art old,</span></span><br><span class="line"><span class="string">And see thy blood warm when thou feel'st it cold."""</span>.split()</span><br><span class="line"><span class="comment"># we should tokenize the input, but we will ignore that for now</span></span><br><span class="line"><span class="comment"># 我们本应该需要标记输入文本，但此次我们忽略这一工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build a list of tuples.  Each tuple is ([ word_i-2, word_i-1 ], target word)</span></span><br><span class="line"><span class="comment"># 建立一个元组列表，每个元组是一个([ word_i-2, word_i-1 ], target word)</span></span><br><span class="line">trigrams = [([test_sentence[i], test_sentence[i + <span class="number">1</span>]], test_sentence[i + <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_sentence) - <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the first 3, just so you can see what they look like</span></span><br><span class="line">print(trigrams[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<blockquote>
<p>[([‘When’, ‘forty’], ‘winters’), ([‘forty’, ‘winters’], ‘shall’), ([‘winters’, ‘shall’], ‘besiege’)]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab = set(test_sentence)</span><br><span class="line">word_to_ix = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NGramLanguageModeler</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embedding_dim, context_size)</span>:</span></span><br><span class="line">    super(NGramLanguageModeler, self).__init__()</span><br><span class="line">    self.embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">    self.linear1 = nn.Linear(context_size * embedding_dim, <span class="number">128</span>)</span><br><span class="line">    self.linear2 = nn.Linear(<span class="number">128</span>, vocab_size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">    embeds = self.embeddings(inputs).view((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">    out = F.relu(self.linear1(embeds))</span><br><span class="line">    out = self.linear2(out)</span><br><span class="line">    log_probs = F.log_softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> log_probs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line">loss_function = nn.NLLLoss()</span><br><span class="line">model = NGramLanguageModeler(len(vocab), EMBEDDING_DIM, CONTEXT_SIZE)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> context, target <span class="keyword">in</span> trigrams:</span><br><span class="line">        <span class="comment"># Step 1. Prepare the inputs to be passed to the model (i.e, turn the words</span></span><br><span class="line">        <span class="comment"># into integer indices and wrap them in tensors)</span></span><br><span class="line">        <span class="comment"># 1. 送入模型前的准备工作（如：将单词转化为对应的索引，并张量化）</span></span><br><span class="line">        context_idxs = torch.tensor([word_to_ix[w] <span class="keyword">for</span> w <span class="keyword">in</span> context], dtype=torch.long)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2. Recall that torch *accumulates* gradients. Before passing in a</span></span><br><span class="line">        <span class="comment"># new instance, you need to zero out the gradients from the old instance</span></span><br><span class="line">        <span class="comment"># 2. Pytorch 能积累梯度，因此在传入新实例之前需要将旧梯度清零</span></span><br><span class="line">        model.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 3. Run the forward pass, getting log probabilities over next words</span></span><br><span class="line">        <span class="comment"># 3. 前向传播，求下一个单词的对数概率</span></span><br><span class="line">        log_probs = model(context_idxs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4. Compute your loss function. (Again, Torch wants the target</span></span><br><span class="line">        <span class="comment"># word wrapped in a tensor)</span></span><br><span class="line">        <span class="comment"># 4. 计算损失函数（Pytorch要求将目标单词转换为张量）</span></span><br><span class="line">        loss = loss_function(log_probs, torch.tensor([word_to_ix[target]], dtype=torch.long))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5. Do the backward pass and update the gradient</span></span><br><span class="line">        <span class="comment"># 5. 反向传播，更新梯度</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the Python number from a 1-element Tensor by calling tensor.item()</span></span><br><span class="line">        <span class="comment"># 使用tensor.item()方法来从单一元素张量中取得数据</span></span><br><span class="line">		total_loss += loss.item()</span><br><span class="line">	losses.append(total_loss)</span><br><span class="line"></span><br><span class="line">print(losses)  <span class="comment"># The loss decreased every iteration over the training data!（误差每次迭代都下降）</span></span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<blockquote>
<p>[518.5035681724548, 516.1092879772186, 513.7281634807587, 511.3589131832123, 509.00272035598755, 506.6583275794983, 504.32336044311523, 501.9988875389099, 499.68528985977173, 497.3804793357849]</p>
</blockquote>
<hr>
<h2 id="练习：计算词嵌入：连续词袋模型"><a href="#练习：计算词嵌入：连续词袋模型" class="headerlink" title="练习：计算词嵌入：连续词袋模型"></a>练习：计算词嵌入：连续词袋模型</h2><blockquote>
<p>Exercise: Computing Word Embeddings: Continuous Bag-of-Words</p>
</blockquote>
<p><a href="https://blog.csdn.net/u010665216/article/details/78724856" target="_blank" rel="noopener">连续词袋模型（CBOW）</a>是自然语言处理中非常常用的一种语言模型。CBOW通过参考目标单词上下文几个单词来对目标单词进行预测。与语言建模不同的是，CBOW并非顺序模型，也不必一定是概率化的。CBOW通常被用来快速训练词嵌入，并且用这些训练得到的词嵌入来初始化那些更为复杂的词嵌入模型，通常这一过程也被称为预训练词嵌入。CBOW绝大多数情况下能够使模型表现提升数个百分点。</p>
<p>以下定义CBOW模型：</p>
<p>给定目标单词 $w_i$ 以及左右两边大小为 N 的上下文窗口：$w_{i-1},\dots, w_{i-N}$ 和 $w_{i+1},\dots, w_{i+N}$，将上述这些上下文单词记做 $c$ ，CBOW模型尝试最小化以下内容：<br>$$<br>-\log p(w_i | C) = -\log \text{Softmax}(A(\sum_{w \in C} q_w) + b)<br>$$<br>其中，$q_w$是单词w的词嵌入。</p>
<p><code>使用Pytorch，完善下面的类，实现这一模型。</code></p>
<p>提示：</p>
<ul>
<li>考虑需要定义哪些参数/变量</li>
<li>明确每步操作要求的形状，需要变换张量形状时，使用<code>.view()</code>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONTEXT_SIZE = <span class="number">2</span>  <span class="comment"># 2 words to the left, 2 to the right（考虑目标单词左右2个单词）</span></span><br><span class="line">raw_text = <span class="string">"""We are about to study the idea of a computational process.</span></span><br><span class="line"><span class="string">Computational processes are abstract beings that inhabit computers.</span></span><br><span class="line"><span class="string">As they evolve, processes manipulate other abstract things called data.</span></span><br><span class="line"><span class="string">The evolution of a process is directed by a pattern of rules</span></span><br><span class="line"><span class="string">called a program. People create programs to direct processes. In effect,</span></span><br><span class="line"><span class="string">we conjure the spirits of the computer with our spells."""</span>.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># By deriving a set from `raw_text`, we deduplicate the array</span></span><br><span class="line"><span class="comment">#通过集合化，将元素唯一化</span></span><br><span class="line">vocab = set(raw_text)</span><br><span class="line">vocab_size = len(vocab)</span><br><span class="line"></span><br><span class="line">word_to_ix = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(raw_text) - <span class="number">2</span>):</span><br><span class="line">    context = [raw_text[i - <span class="number">2</span>], raw_text[i - <span class="number">1</span>], raw_text[i + <span class="number">1</span>], raw_text[i + <span class="number">2</span>]]</span><br><span class="line">    target = raw_text[i]</span><br><span class="line">    data.append((context, target))</span><br><span class="line">print(data[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<blockquote>
<p>[([‘We’, ‘are’, ‘to’, ‘study’], ‘about’), ([‘are’, ‘about’, ‘study’, ‘the’], ‘to’), ([‘about’, ‘to’, ‘the’, ‘idea’], ‘study’), ([‘to’, ‘study’, ‘idea’, ‘of’], ‘the’), ([‘study’, ‘the’, ‘of’, ‘a’], ‘idea’)]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBOW</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># create your model and train.  here are some functions to help you make</span></span><br><span class="line"><span class="comment"># the data ready for use by your module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_context_vector</span><span class="params">(context, word_to_ix)</span>:</span></span><br><span class="line">    idxs = [word_to_ix[w] <span class="keyword">for</span> w <span class="keyword">in</span> context]</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(idxs, dtype=torch.long)</span><br><span class="line"></span><br><span class="line">make_context_vector(data[<span class="number">0</span>][<span class="number">0</span>], word_to_ix)  <span class="comment"># example</span></span><br></pre></td></tr></table></figure>

<p>该练习答案后续更新。</p>
<hr>
<p>[Translation] 2020/4 Karl</p>
]]></content>
      <categories>
        <category>Translations</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-29</title>
    <url>/2020/04/29/leetcode-day-29/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-29"><a href="#LeetCode-30-days-Challenge-Day-29" class="headerlink" title="LeetCode 30 days Challenge - Day 29"></a>LeetCode 30 days Challenge - Day 29</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h2><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵非空二叉树，求其中最大路径和。注意此处的路径不一定经过根结点，路径至少有一个节点。</p>
<p>解法：</p>
<p>本题需要注意的是，存在负数结点值，传统的递归思想无法满足题目要求。</p>
<p>对于当前结点，维护一个最大值变量res，我们需要考虑：</p>
<ol>
<li><p><strong>路径不允许分叉，那么若当前结点存在父节点、经过当前结点、还要向父节点走的路径只可能经过当前结点的左右子树之一，该定义是递归的。在下文，称这种情况为<code>无分叉子树</code></strong></p>
</li>
<li><p>最终经过当前结点的最大路径只有四种情况：</p>
<ol>
<li><p>经过当前结点、不经过子树：<code>无分叉子树最大路径和都为负数</code></p>
<p><code>res = max(res, node-&gt;val + max(0, l) + max(0, r));</code></p>
</li>
<li><p>经过当前结点、当前节点的左子树、当前节点的右子树：<code>两颗无分叉子树最大路径和都不为负数</code></p>
<p><code>res = max(res, node-&gt;val + max(0, l) + max(0, r));</code></p>
</li>
<li><p>经过当前结点、当前节点的左子树：<code>右无分叉子树最大路径和不为负数</code></p>
<p>更新无分叉子树的最大路径和：<code>node-&gt;val += max(0, max(l, r));</code></p>
</li>
<li><p>经过当前结点、当前节点的右子树：<code>左无分叉子树最大路径和不为负数</code></p>
<p>更新无分叉子树的最大路径和：<code>node-&gt;val += max(0, max(l, r));</code></p>
</li>
</ol>
</li>
</ol>
<p>按以上思路，题解如下：</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSubPathSum</span><span class="params">(TreeNode* node, <span class="keyword">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = getSubPathSum(node-&gt;left, res);</span><br><span class="line">    <span class="keyword">int</span> r = getSubPathSum(node-&gt;right, res);</span><br><span class="line">    res = max(res, node-&gt;val + max(<span class="number">0</span>, l) + max(<span class="number">0</span>, r));</span><br><span class="line">    node-&gt;val += max(<span class="number">0</span>, max(l, r));</span><br><span class="line">    <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    getSubPathSum(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3314/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-day-30</title>
    <url>/2020/04/30/leetcode-day-30/</url>
    <content><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-30"><a href="#LeetCode-30-days-Challenge-Day-30" class="headerlink" title="LeetCode 30 days Challenge - Day 30"></a>LeetCode 30 days Challenge - Day 30</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p>
<hr>
<h2 id="Check-If-a-String-Is-a-Valid-Sequence-from-Root-to-Leaves-Path-in-a-Binary-Tree"><a href="#Check-If-a-String-Is-a-Valid-Sequence-from-Root-to-Leaves-Path-in-a-Binary-Tree" class="headerlink" title="Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree"></a>Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</h2><p>Given a binary tree where each path going from the root to any leaf form a <strong>valid sequence</strong>, check if a given string is a <strong>valid sequence</strong> in such binary tree. </p>
<p>We get the given string from the concatenation of an array of integers <code>arr</code> and the concatenation of all values of the nodes along a path results in a <strong>sequence</strong> in the given binary tree.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_1.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [0,1,0,0,1,0,null,null,1,0,0], arr &#x3D; [0,1,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The path 0 -&gt; 1 -&gt; 0 -&gt; 1 is a valid sequence (green color in the figure). </span><br><span class="line">Other valid sequences are: </span><br><span class="line">0 -&gt; 1 -&gt; 1 -&gt; 0 </span><br><span class="line">0 -&gt; 0 -&gt; 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_2.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [0,1,0,0,1,0,null,null,1,0,0], arr &#x3D; [0,0,1]</span><br><span class="line">Output: false </span><br><span class="line">Explanation: The path 0 -&gt; 0 -&gt; 1 does not exist, therefore it is not even a sequence.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_3.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [0,1,0,0,1,0,null,null,1,0,0], arr &#x3D; [0,1,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The path 0 -&gt; 1 -&gt; 1 is a sequence, but it is not a valid sequence.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
<li>Each node’s value is between [0 - 9].</li>
</ul>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵二叉树以及一个整型数组，定义<code>从根出发直到叶子结点结束</code>的路径为一个<code>有效序列</code>，且整型数组按照元素位置连接成一个<code>序列</code>，求是否存在一个有效序列与数组确定的序列相同。</p>
<p>解法：</p>
<p>本题原题比较绕口、难以理解，实际上就是从二叉树根出发，寻找一条直达叶子结点的路径，路径上每个结点值依次与给定的整型数组相等。</p>
<p>理解清楚题意后，本题就变得比较简单，DFS即可解决。</p>
<p>这里梳理一下DFS过程中的退出条件，以下称数组确定的序列为<code>目标序列</code>：</p>
<ol>
<li><strong>当前位置已经超过数组长度：</strong>说明该路径还没到达叶子结点就已经超过目标序列的最大长度了，返回<code>false</code>。</li>
<li><strong>当前位置未超过数组长度，且没有左右孩子，为叶子结点：</strong>说明当前路径是一个<code>有效序列</code>，且目标序列和该有效序列除了尾部元素其余值一致。因此只需要判断目标序列是否也到达尾部元素，尾部元素值是否与该叶子节点值相等，满足则该<code>有效序列</code>即为<code>目标序列</code>，返回<code>true</code>，反之返回<code>false</code>。</li>
<li><strong>当前位置未超过数组长度，且不是叶子结点，且该位置元素值不等于目标序列对应位置元素值：</strong>说明该路径失效，返回<code>false</code>。</li>
<li><strong>当前位置未超过数组长度、不是叶子结点、该位置元素值等于目标序列对应位置元素值：</strong>说明迄今为止的路径都满足目标序列的要求，需要接着往下考虑：对存在的孩子结点进行DFS，且只要有一个孩子满足条件就返回<code>true</code>，都不满足才返回<code>false</code>。</li>
</ol>
<p>以上解释为追求普适性，比较啰嗦，可以直接参考代码，代码可读性较强。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; arr.size() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// leaf</span></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> (pos == arr.size() - <span class="number">1</span> &amp;&amp; node-&gt;val == arr[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// non-leaf</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;val != arr[pos]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) flag = dfs(node-&gt;left, arr, pos+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right) flag = flag || dfs(node-&gt;right, arr, pos+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSequence</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, arr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/" target="_blank" rel="noopener">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a></p>
<p>Karl</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
