<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Karl&#39;s Nest</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://karlszp.github.io/"/>
  <updated>2020-04-29T11:02:54.027Z</updated>
  <id>https://karlszp.github.io/</id>
  
  <author>
    <name>Karl Szp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-day-29</title>
    <link href="https://karlszp.github.io/2020/04/29/leetcode-day-29/"/>
    <id>https://karlszp.github.io/2020/04/29/leetcode-day-29/</id>
    <published>2020-04-29T11:02:35.000Z</published>
    <updated>2020-04-29T11:02:54.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-29"><a href="#LeetCode-30-days-Challenge-Day-29" class="headerlink" title="LeetCode 30 days Challenge - Day 29"></a>LeetCode 30 days Challenge - Day 29</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h2><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵非空二叉树，求其中最大路径和。注意此处的路径不一定经过根结点，路径至少有一个节点。</p><p>解法：</p><p>本题需要注意的是，存在负数结点值，传统的递归思想无法满足题目要求。</p><p>对于当前结点，维护一个最大值变量res，我们需要考虑：</p><ol><li><p><strong>路径不允许分叉，那么若当前结点存在父节点、经过当前结点、还要向父节点走的路径只可能经过当前结点的左右子树之一，该定义是递归的。在下文，称这种情况为<code>无分叉子树</code></strong></p></li><li><p>最终经过当前结点的最大路径只有四种情况：</p><ol><li><p>经过当前结点、不经过子树：<code>无分叉子树最大路径和都为负数</code></p><p><code>res = max(res, node-&gt;val + max(0, l) + max(0, r));</code></p></li><li><p>经过当前结点、当前节点的左子树、当前节点的右子树：<code>两颗无分叉子树最大路径和都不为负数</code></p><p><code>res = max(res, node-&gt;val + max(0, l) + max(0, r));</code></p></li><li><p>经过当前结点、当前节点的左子树：<code>右无分叉子树最大路径和不为负数</code></p><p>更新无分叉子树的最大路径和：<code>node-&gt;val += max(0, max(l, r));</code></p></li><li><p>经过当前结点、当前节点的右子树：<code>左无分叉子树最大路径和不为负数</code></p><p>更新无分叉子树的最大路径和：<code>node-&gt;val += max(0, max(l, r));</code></p></li></ol></li></ol><p>按以上思路，题解如下：</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSubPathSum</span><span class="params">(TreeNode* node, <span class="keyword">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = getSubPathSum(node-&gt;left, res);</span><br><span class="line">    <span class="keyword">int</span> r = getSubPathSum(node-&gt;right, res);</span><br><span class="line">    res = max(res, node-&gt;val + max(<span class="number">0</span>, l) + max(<span class="number">0</span>, r));</span><br><span class="line">    node-&gt;val += max(<span class="number">0</span>, max(l, r));</span><br><span class="line">    <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    getSubPathSum(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3314/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-29 Binary Tree Maximum Path Sum
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch-tutorial-word-embedding</title>
    <link href="https://karlszp.github.io/2020/04/29/Pytorch-tutorial-word-embedding/"/>
    <id>https://karlszp.github.io/2020/04/29/Pytorch-tutorial-word-embedding/</id>
    <published>2020-04-29T08:55:37.000Z</published>
    <updated>2020-04-29T09:02:28.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文传送门：<a href="https://pytorch.org/tutorials/beginner/nlp/word_embeddings_tutorial.html" target="_blank" rel="noopener">WORD EMBEDDINGS: ENCODING LEXICAL SEMANTICS</a></p></blockquote><h1 id="译-Pytorch-官方教程-词嵌入：编码词语与语义"><a href="#译-Pytorch-官方教程-词嵌入：编码词语与语义" class="headerlink" title="[译] Pytorch 官方教程 词嵌入：编码词语与语义"></a>[译] Pytorch 官方教程 词嵌入：编码词语与语义</h1><blockquote><p>WORD EMBEDDINGS: ENCODING LEXICAL SEMANTICS</p></blockquote><p>词嵌入指的是：将用户词表中每一个单词与一个实数对应，并嵌入到一个<a href="https://stackoverflow.com/questions/31522893/sparse-vector-vs-dense-vector" target="_blank" rel="noopener">密度向量</a>中。在自然语言处理中，绝大多数情况研究的特征都是单词。然而，应该怎样在计算机中表示一个单词呢？一种方案是存储单词每个字母对应的ascii码，但这只能让我们知道我们存储的这个单词由哪些字母组成，并不能表达这个单词具体的含义（或许能从词缀推断出词性、从大小写推断出属性，但这远远不够）。而且，凭什么可以将这些表示组合在一起？</p><p>我们设计的神经网络往往是$|V|$（词汇表的长度）维的，但是却需要从神经网络中得到低维、密集的输出（譬如需要预测的标签只有几个），我们要怎样从将数据从高维空间转移到低维空间呢？</p><p>不妨试试用<a href="https://blog.csdn.net/chary8088/article/details/79032223" target="_blank" rel="noopener">one-hot编码</a>来代替ascii码？即，对某个单词w，按以下方式表示：<br>$$<br>\overbrace{\left[ 0, 0, \dots, 1, \dots, 0, 0 \right]}^\text{|V| elements}<br>$$<br>其中，每个单词都只含有1个’1’（剩余为0），而且每个单词的’1’的位置都不同。</p><p>上述方法不仅占用了巨量的空间，而且还有一个致命的弊端：这种方法将每个单词标记为独立的实体，认为他们之间没有关联。</p><p>我们真正想要的，是使用一些标记方法，来<code>标记词与词之间的相似关系</code>。难以理解？且看以下示例。</p><p>假设我们正在建立一个语言模型，假设有以下语句：</p><ul><li>The mathematician ran to the store.</li><li>The physicist ran to the store.</li><li>The mathematician solved the open problem.</li></ul><p>在我们的训练数据中。</p><p>现在，我们读取到了一个在训练数据中从未见过的语句：</p><ul><li>The physicist solved the open problem.</li></ul><p>我们的语言模型在这一语句上也许能表现不错，但如果能够将以下两个事实也考虑进去，相信将会更好：</p><ul><li>我们在训练语句中，发现mathematician以及physicist在句中是相同的成分，换句话说，他们有着一定的语义关系。</li><li>在新语句中，虽然看到的是physicist，但是我们认为mathematician在句中的成分是和physicist一致的。</li></ul><p>由此，推断出physicist在新语句中的拟合度很好。</p><p>这正是上述<code>标记词与词之间的相似关系</code>的真实含义：相似关系指的是语义上的相似，而不是指字符拼写上相似。</p><p>这一技术在训练数据和未知的数据之间建立了联系，能有效克服语言学（文本）数据的稀疏性。当然，这基于一个基本假设：出现在相似上下文之中的单词在语义上相关。这也被称为<a href="https://en.wikipedia.org/wiki/Distributional_semantics" target="_blank" rel="noopener">分布式假设</a>。</p><hr><h2 id="稠密词嵌入"><a href="#稠密词嵌入" class="headerlink" title="稠密词嵌入"></a>稠密词嵌入</h2><blockquote><p>Getting Dense Word Embeddings</p></blockquote><p>如何获得词嵌入呢？换句话说，我们具体要如何将语义的相似性进行编码？</p><p>或许我们可以考虑一些语义属性。例如，<code>is able to run</code>属性：mathematicians 和 physicists 都能 “run”，因此二者在该属性上都标记为高分。再考虑一些属性，并且为这些属性对不同的单词进行打分。</p><p>如果将每个属性视为一个维度，那么我们能将每个单词表示为一个向量（词嵌入向量）：<br>$$<br>q_\text{mathematician} = \left[ \overbrace{2.3}^\text{can run}, \overbrace{9.4}^\text{likes coffee}, \overbrace{-5.5}^\text{majored in Physics}, \dots \right]<br>$$</p><p>$$<br>q_\text{physicist} = \left[ \overbrace{2.5}^\text{can run},<br>\overbrace{9.1}^\text{likes coffee}, \overbrace{6.4}^\text{majored in Physics}, \dots \right]<br>$$</p><p>由此，我们得到了度量单词相似性的一个方法：<br>$$<br>\text{Similarity}(\text{physicist}, \text{mathematician}) = q_\text{physicist} \cdot q_\text{mathematician}<br>$$<br>按照向量长度标准化后：<br>$$<br>\text{Similarity}(\text{physicist}, \text{mathematician}) = \frac{q_\text{physicist} \cdot q_\text{mathematician}}<br>{| q_\text{physicist} | | q_\text{mathematician} |} = \cos (\phi)<br>$$<br>其中，$\phi$ 标记两个向量的夹角。这样一来，极度相似的单词（他们的词嵌入向量指向几乎相同的方向）的similarity值为1，极度不相似的单词（他们的词嵌入向量指向几乎相反的方向）的similarity值为-1，</p><p>现在回顾one-hot编码，可以将其看成词嵌入向量的一种特殊情况，每个单词的相似度为0，且为每个单词单独分配了一个唯一的语义属性。</p><p>同时，我们称新定义的向量是稠密的，也就是说这些向量的元素绝大多数不为0。</p><p>然而， 这些新定义的向量有一个大问题：我们能为相似性的度量，定义成千上万个不同的语义属性，那么到底如何为不同的属性打分呢？</p><p>深度学习的核心思想是使计算机利用神经网络自动学习特征的含义，而不是需要程序员来手动设计。那么，为何不将词嵌入作为模型参数，让词嵌入在训练过程中自动更新迭代呢？</p><p>这正是我们要做的：我们将设计一些神经网络在原则上能够进行学习的<code>潜在语义属性</code>。注意，词嵌入可能是难以解释甚至不可解释的。也就是说，虽然在上述例子中，我们能通过手工标记的方法知道mathematicians以及physicists都喜欢咖啡，但是如果我们用一个神经网络去学习这些词嵌入，并且发现mathematicians以及physicists的词嵌入在某个维度上都有着很高的分数，我们也不清楚这个维度到底意味着什么（即不明该维度的语义）。他们在潜在语义属性上相似，但这对我们来说不可解释。</p><p>总而言之，<strong>词嵌入表示的是单词语义，能够高效地编码与手头任务相关的语义信息</strong>。除了语义信息，还能够嵌入其他的信息：词性标签、语义分析树、甚至任意信息！特征嵌入的思想是这一领域的核心。</p><hr><h2 id="Pytorch中的词嵌入"><a href="#Pytorch中的词嵌入" class="headerlink" title="Pytorch中的词嵌入"></a>Pytorch中的词嵌入</h2><blockquote><p>Word Embeddings in Pytorch</p></blockquote><p>（部分内容已省略）</p><p>在定义词嵌入时，我们需要为每一个单词定义一个索引，这些索引将会成为一个查询表中的键值。</p><p>换句话说，词嵌入将被存储为一个$|V|×D $的矩阵，D为词嵌入的维度。我们为<code>某一单词定义的索引i即表示该单词在词嵌入矩阵中的第i行</code>。下文中，从单词到其索引的映射将被命名为 <code>word_to_ix</code>。</p><p>Pytorch中为词嵌入提供服务的模块是 <code>torch.nn.Embedding</code>，<code>torch.nn.Embedding</code>接受两个参数：<code>词汇表长度、词嵌入维度</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Guthrie</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word_to_ix = &#123;<span class="string">"hello"</span>: <span class="number">0</span>, <span class="string">"world"</span>: <span class="number">1</span>&#125;</span><br><span class="line">embeds = nn.Embedding(<span class="number">2</span>, <span class="number">5</span>)  <span class="comment"># 2 words in vocab, 5 dimensional embeddings（词汇表长度为2，嵌入维度为5）</span></span><br><span class="line">lookup_tensor = torch.tensor([word_to_ix[<span class="string">"hello"</span>]], dtype=torch.long)</span><br><span class="line">hello_embed = embeds(lookup_tensor)</span><br><span class="line">print(hello_embed)</span><br></pre></td></tr></table></figure><p><strong>Out:</strong></p><blockquote><p>tensor([[ 0.6614,  0.2669,  0.0617,  0.6213, -0.4519]],<br>    grad_fn=<EmbeddingBackward>)</p></blockquote><hr><h2 id="示例：N-Gram-语言模型"><a href="#示例：N-Gram-语言模型" class="headerlink" title="示例：N-Gram 语言模型"></a>示例：N-Gram 语言模型</h2><blockquote><p>An Example: N-Gram Language Modeling</p></blockquote><p>回顾n-gram模型，给定一个单词序列 w，我们需要计算：<br>$$<br>P(w_i | w_{i-1}, w_{i-2}, \dots, w_{i-n+1} )<br>$$<br>其中 $w_i$ 是w中的第i个单词。</p><p>在本例中，我们将计算一些训练样本的<code>损失函数</code>然后使用<code>反向传播来更新模型参数</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT_SIZE = <span class="number">2</span></span><br><span class="line">EMBEDDING_DIM = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We will use Shakespeare Sonnet 2</span></span><br><span class="line"><span class="comment"># 使用莎士比亚的《十四行诗》2</span></span><br><span class="line">test_sentence = <span class="string">"""When forty winters shall besiege thy brow,</span></span><br><span class="line"><span class="string">And dig deep trenches in thy beauty's field,</span></span><br><span class="line"><span class="string">Thy youth's proud livery so gazed on now,</span></span><br><span class="line"><span class="string">Will be a totter'd weed of small worth held:</span></span><br><span class="line"><span class="string">Then being asked, where all thy beauty lies,</span></span><br><span class="line"><span class="string">Where all the treasure of thy lusty days;</span></span><br><span class="line"><span class="string">To say, within thine own deep sunken eyes,</span></span><br><span class="line"><span class="string">Were an all-eating shame, and thriftless praise.</span></span><br><span class="line"><span class="string">How much more praise deserv'd thy beauty's use,</span></span><br><span class="line"><span class="string">If thou couldst answer 'This fair child of mine</span></span><br><span class="line"><span class="string">Shall sum my count, and make my old excuse,'</span></span><br><span class="line"><span class="string">Proving his beauty by succession thine!</span></span><br><span class="line"><span class="string">This were to be new made when thou art old,</span></span><br><span class="line"><span class="string">And see thy blood warm when thou feel'st it cold."""</span>.split()</span><br><span class="line"><span class="comment"># we should tokenize the input, but we will ignore that for now</span></span><br><span class="line"><span class="comment"># 我们本应该需要标记输入文本，但此次我们忽略这一工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build a list of tuples.  Each tuple is ([ word_i-2, word_i-1 ], target word)</span></span><br><span class="line"><span class="comment"># 建立一个元组列表，每个元组是一个([ word_i-2, word_i-1 ], target word)</span></span><br><span class="line">trigrams = [([test_sentence[i], test_sentence[i + <span class="number">1</span>]], test_sentence[i + <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_sentence) - <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the first 3, just so you can see what they look like</span></span><br><span class="line">print(trigrams[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>Out:</strong></p><blockquote><p>[([‘When’, ‘forty’], ‘winters’), ([‘forty’, ‘winters’], ‘shall’), ([‘winters’, ‘shall’], ‘besiege’)]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">vocab = set(test_sentence)</span><br><span class="line">word_to_ix = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NGramLanguageModeler</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embedding_dim, context_size)</span>:</span></span><br><span class="line">    super(NGramLanguageModeler, self).__init__()</span><br><span class="line">    self.embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">    self.linear1 = nn.Linear(context_size * embedding_dim, <span class="number">128</span>)</span><br><span class="line">    self.linear2 = nn.Linear(<span class="number">128</span>, vocab_size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">    embeds = self.embeddings(inputs).view((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">    out = F.relu(self.linear1(embeds))</span><br><span class="line">    out = self.linear2(out)</span><br><span class="line">    log_probs = F.log_softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> log_probs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line">loss_function = nn.NLLLoss()</span><br><span class="line">model = NGramLanguageModeler(len(vocab), EMBEDDING_DIM, CONTEXT_SIZE)</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> context, target <span class="keyword">in</span> trigrams:</span><br><span class="line">        <span class="comment"># Step 1. Prepare the inputs to be passed to the model (i.e, turn the words</span></span><br><span class="line">        <span class="comment"># into integer indices and wrap them in tensors)</span></span><br><span class="line">        <span class="comment"># 1. 送入模型前的准备工作（如：将单词转化为对应的索引，并张量化）</span></span><br><span class="line">        context_idxs = torch.tensor([word_to_ix[w] <span class="keyword">for</span> w <span class="keyword">in</span> context], dtype=torch.long)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2. Recall that torch *accumulates* gradients. Before passing in a</span></span><br><span class="line">        <span class="comment"># new instance, you need to zero out the gradients from the old instance</span></span><br><span class="line">        <span class="comment"># 2. Pytorch 能积累梯度，因此在传入新实例之前需要将旧梯度清零</span></span><br><span class="line">        model.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 3. Run the forward pass, getting log probabilities over next words</span></span><br><span class="line">        <span class="comment"># 3. 前向传播，求下一个单词的对数概率</span></span><br><span class="line">        log_probs = model(context_idxs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4. Compute your loss function. (Again, Torch wants the target</span></span><br><span class="line">        <span class="comment"># word wrapped in a tensor)</span></span><br><span class="line">        <span class="comment"># 4. 计算损失函数（Pytorch要求将目标单词转换为张量）</span></span><br><span class="line">        loss = loss_function(log_probs, torch.tensor([word_to_ix[target]], dtype=torch.long))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5. Do the backward pass and update the gradient</span></span><br><span class="line">        <span class="comment"># 5. 反向传播，更新梯度</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the Python number from a 1-element Tensor by calling tensor.item()</span></span><br><span class="line">        <span class="comment"># 使用tensor.item()方法来从单一元素张量中取得数据</span></span><br><span class="line">total_loss += loss.item()</span><br><span class="line">losses.append(total_loss)</span><br><span class="line"></span><br><span class="line">print(losses)  <span class="comment"># The loss decreased every iteration over the training data!（误差每次迭代都下降）</span></span><br></pre></td></tr></table></figure><p><strong>Out:</strong></p><blockquote><p>[518.5035681724548, 516.1092879772186, 513.7281634807587, 511.3589131832123, 509.00272035598755, 506.6583275794983, 504.32336044311523, 501.9988875389099, 499.68528985977173, 497.3804793357849]</p></blockquote><hr><h2 id="练习：计算词嵌入：连续词袋模型"><a href="#练习：计算词嵌入：连续词袋模型" class="headerlink" title="练习：计算词嵌入：连续词袋模型"></a>练习：计算词嵌入：连续词袋模型</h2><blockquote><p>Exercise: Computing Word Embeddings: Continuous Bag-of-Words</p></blockquote><p><a href="https://blog.csdn.net/u010665216/article/details/78724856" target="_blank" rel="noopener">连续词袋模型（CBOW）</a>是自然语言处理中非常常用的一种语言模型。CBOW通过参考目标单词上下文几个单词来对目标单词进行预测。与语言建模不同的是，CBOW并非顺序模型，也不必一定是概率化的。CBOW通常被用来快速训练词嵌入，并且用这些训练得到的词嵌入来初始化那些更为复杂的词嵌入模型，通常这一过程也被称为预训练词嵌入。CBOW绝大多数情况下能够使模型表现提升数个百分点。</p><p>以下定义CBOW模型：</p><p>给定目标单词 $w_i$ 以及左右两边大小为 N 的上下文窗口：$w_{i-1},\dots, w_{i-N}$ 和 $w_{i+1},\dots, w_{i+N}$，将上述这些上下文单词记做 $c$ ，CBOW模型尝试最小化以下内容：<br>$$<br>-\log p(w_i | C) = -\log \text{Softmax}(A(\sum_{w \in C} q_w) + b)<br>$$<br>其中，$q_w$是单词w的词嵌入。</p><p><code>使用Pytorch，完善下面的类，实现这一模型。</code></p><p>提示：</p><ul><li>考虑需要定义哪些参数/变量</li><li>明确每步操作要求的形状，需要变换张量形状时，使用<code>.view()</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT_SIZE = <span class="number">2</span>  <span class="comment"># 2 words to the left, 2 to the right（考虑目标单词左右2个单词）</span></span><br><span class="line">raw_text = <span class="string">"""We are about to study the idea of a computational process.</span></span><br><span class="line"><span class="string">Computational processes are abstract beings that inhabit computers.</span></span><br><span class="line"><span class="string">As they evolve, processes manipulate other abstract things called data.</span></span><br><span class="line"><span class="string">The evolution of a process is directed by a pattern of rules</span></span><br><span class="line"><span class="string">called a program. People create programs to direct processes. In effect,</span></span><br><span class="line"><span class="string">we conjure the spirits of the computer with our spells."""</span>.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># By deriving a set from `raw_text`, we deduplicate the array</span></span><br><span class="line"><span class="comment">#通过集合化，将元素唯一化</span></span><br><span class="line">vocab = set(raw_text)</span><br><span class="line">vocab_size = len(vocab)</span><br><span class="line"></span><br><span class="line">word_to_ix = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab)&#125;</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(raw_text) - <span class="number">2</span>):</span><br><span class="line">    context = [raw_text[i - <span class="number">2</span>], raw_text[i - <span class="number">1</span>], raw_text[i + <span class="number">1</span>], raw_text[i + <span class="number">2</span>]]</span><br><span class="line">    target = raw_text[i]</span><br><span class="line">    data.append((context, target))</span><br><span class="line">print(data[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><strong>Out:</strong></p><blockquote><p>[([‘We’, ‘are’, ‘to’, ‘study’], ‘about’), ([‘are’, ‘about’, ‘study’, ‘the’], ‘to’), ([‘about’, ‘to’, ‘the’, ‘idea’], ‘study’), ([‘to’, ‘study’, ‘idea’, ‘of’], ‘the’), ([‘study’, ‘the’, ‘of’, ‘a’], ‘idea’)]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBOW</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># create your model and train.  here are some functions to help you make</span></span><br><span class="line"><span class="comment"># the data ready for use by your module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_context_vector</span><span class="params">(context, word_to_ix)</span>:</span></span><br><span class="line">    idxs = [word_to_ix[w] <span class="keyword">for</span> w <span class="keyword">in</span> context]</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(idxs, dtype=torch.long)</span><br><span class="line"></span><br><span class="line">make_context_vector(data[<span class="number">0</span>][<span class="number">0</span>], word_to_ix)  <span class="comment"># example</span></span><br></pre></td></tr></table></figure><p>该练习答案后续更新。</p><hr><p>[Translation] 2020/4 Karl</p>]]></content>
    
    <summary type="html">
    
      [译] Pytorch 官方教程 词嵌入：编码词语与语义
    
    </summary>
    
    
      <category term="Translations" scheme="https://KARLSZP.github.io/categories/Translations/"/>
    
    
      <category term="Python" scheme="https://KARLSZP.github.io/tags/Python/"/>
    
      <category term="DeepLearning" scheme="https://KARLSZP.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-28</title>
    <link href="https://karlszp.github.io/2020/04/28/leetcode-day-28/"/>
    <id>https://karlszp.github.io/2020/04/28/leetcode-day-28/</id>
    <published>2020-04-28T14:24:07.000Z</published>
    <updated>2020-04-28T14:24:30.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-28"><a href="#LeetCode-30-days-Challenge-Day-28" class="headerlink" title="LeetCode 30 days Challenge - Day 28"></a>LeetCode 30 days Challenge - Day 28</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="First-Unique-Number"><a href="#First-Unique-Number" class="headerlink" title="First Unique Number"></a>First Unique Number</h2><p>You have a queue of integers, you need to retrieve the first unique integer in the queue.</p><p>Implement the <code>FirstUnique</code> class:</p><ul><li><code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.</li><li><code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.</li><li><code>void add(int value)</code> insert value to the queue. </li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[2,3,5]],[],[5],[],[2],[],[3],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,2,null,2,null,3,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([2,3,5]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(5);            &#x2F;&#x2F; the queue is now [2,3,5,5]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(2);            &#x2F;&#x2F; the queue is now [2,3,5,5,2]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 3</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [2,3,5,5,2,3]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,-1,null,null,null,null,null,17]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([7,7,7,7,7,7]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3]</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7]</span><br><span class="line">firstUnique.add(17);           &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7,17]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 17</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[809]],[],[809],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,809,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([809]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 809</span><br><span class="line">firstUnique.add(809);          &#x2F;&#x2F; the queue is now [809,809]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^8</code></li><li><code>1 &lt;= value &lt;= 10^8</code></li><li>At most <code>50000</code> calls will be made to <code>showFirstUnique</code> and <code>add</code>.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个能够返回<code>第一个唯一元素</code>的队列。要求实现：1.返回<code>第一个唯一元素</code>的功能；2. 添加一个新元素。</p><p>解法：</p><p>本题重点需要理清，两个功能在各种不同的情况下，应该如何工作：</p><ol><li><code>showFirstUnique()</code>：<ol><li>当队列为空，或没有唯一元素，返回 <code>-1</code>；</li><li>当队列存在唯一元素，返回第一个唯一的<code>元素值</code>。</li></ol></li><li><code>add(int value)</code>：<ol><li>当队列不存在该元素，那么<code>加入队列</code>。</li><li>当队列存在该元素，那么将<code>原来的元素从队列中移除</code>，并且<code>以后不能在加入该元素</code>。</li></ol></li></ol><p>到这里，逻辑思路就整理完毕，接下来考虑数据结构使用问题。</p><ol><li>为了<code>常量时间</code>访存，使用存在头尾指针的双向链表来存储<code>唯一的元素</code>：<ol><li>每个元素初次出现都加入该链表，当重复的元素出现时，从该表移除，且不再加入该表，所以说存储的是“唯一的”元素。</li><li>第一个唯一元素即为第一个链表元素：<code>head-&gt;next == rear ? -1 : head-&gt;next-&gt;val</code>；此处注意对链表是否为空的判断。</li><li>当通过add加入新元素：新元素通过<code>尾插法</code>加入链表，不会打乱原有的相对顺序。</li><li>当出现重复元素，删除某一节点时：参见代码<code>removeNode(ListNode* node)</code>处。</li></ol></li><li>为了<code>常量时间</code>判断元素存在，建立从value到链表指针的映射<code>unordered_map&lt;int, ListNode*&gt; m</code>：<ol><li>添加一个元素时，通过 <code>m.find(value) != m.end()</code>判断元素是否存在。</li><li>若不存在，新建链表结点、插入链表中、将指针赋给<code>m[value]</code>，这样可以通过常量时间访问到该value对应的链表结点。</li><li>为了实现“<code>以后不能在加入该元素</code>”的功能，当出现重复元素时，从链表中删除原元素后，将<code>m[value]</code>指向<code>NULL</code>，未来再次遇到该元素时就不会再次进行删除元素操作（已经不存在该元素，删除操作会造成错误）。</li></ol></li></ol><p>本题值得细品，勿只读解法，务必参考代码，整理清楚逻辑。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstUnique</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) : val(x), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        rear-&gt;pre-&gt;next = node;</span><br><span class="line">        node-&gt;pre = rear-&gt;pre;</span><br><span class="line">        node-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = node;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* rear = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;</span><br><span class="line"></span><br><span class="line">    FirstUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showFirstUnique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == rear ? <span class="number">-1</span> : head-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(value) != m.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[value] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                removeNode(m[value]);</span><br><span class="line">                m[value] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(value) == m.end()) &#123;</span><br><span class="line">            ListNode* node = addNode(value);</span><br><span class="line">            m[value] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/" target="_blank" rel="noopener">First Unique Number</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-28 First Unique Number
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-27</title>
    <link href="https://karlszp.github.io/2020/04/27/leetcode-day-27/"/>
    <id>https://karlszp.github.io/2020/04/27/leetcode-day-27/</id>
    <published>2020-04-27T08:21:15.000Z</published>
    <updated>2020-04-27T09:03:37.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-27"><a href="#LeetCode-30-days-Challenge-Day-27" class="headerlink" title="LeetCode 30 days Challenge - Day 27"></a>LeetCode 30 days Challenge - Day 27</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个值为0或1的二维数组，求其中由1组成的、面积最大的正方形面积。</p><p>解法：</p><p>本题使用动态规划思想，其中<code>dp[i][j]</code>记录以i、j为右下角坐标的正方形的最大边长，从左往右，从上往下遍历一遍数组，并记录其中出现过的最大边长，返回结果即为最大边长的平方。</p><p>dp数组按照以下规则进行更新：</p><ol><li>对i，j：满足以i、j为右下角坐标的正方形边长范围是<code>1 - (min(i, j) + 1)</code>，这些边长的正方形中只要有一个元素不为1，则不能加入结果。</li><li>根据动态规划的思想：当前状态只与其上一个状态有关，即对于上述以i、j为右下角坐标的正方形，边长为 <code>(min(i, j) + 1)</code>的正方形就是<code>当前状态</code>，因此需要考虑其<code>上一个状态</code>即边长为<code>min(i, j)</code>的正方形是如何影响当前状态的。</li><li>不难发现，边长为 <code>(min(i, j) + 1)</code>的正方形除去最右下角元素后含有三个边长为<code>min(i, j)</code>的正方形（分别是去除最右列、最下行，去除最右列、最上行，去除最左列、最下行三种情况），当且仅当这三个正方形都全是1、且位置(i, j)也是1时，<code>dp[i][j]</code>取值为<code>(min(i, j) + 1)</code>；</li><li>综上，规则为：<code>dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1</code></li></ol><p>下图展示了遍历过程中三种情况：</p><p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt=""></p><p>注：最终求的是面积，注意返回最大边长的平方。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3312/" target="_blank" rel="noopener">Maximal Square</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-27 Maximal Square
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-26</title>
    <link href="https://karlszp.github.io/2020/04/27/leetcode-day-26/"/>
    <id>https://karlszp.github.io/2020/04/27/leetcode-day-26/</id>
    <published>2020-04-27T08:20:51.000Z</published>
    <updated>2020-04-27T08:21:11.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-26"><a href="#LeetCode-30-days-Challenge-Day-26" class="headerlink" title="LeetCode 30 days Challenge - Day 26"></a>LeetCode 30 days Challenge - Day 26</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h2><p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p><p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p><p>If there is no common subsequence, return 0. </p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= text1.length &lt;= 1000</code></li><li><code>1 &lt;= text2.length &lt;= 1000</code></li><li>The input strings consist of lowercase English characters only.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定两个字符串，求其中最长公共子串的长度。</p><p>解法：</p><p>本题需要注意区分子序列、子串：subsequence是子序列，子序列中各元素不需要连续，substring是子串，子串中每个元素必须是连续的。</p><p>本题是经典的动态规划题，维护一个二维动态规划数组dp，其中：</p><ol><li><code>i：1 - text1.length()</code>；<code>j：1 - text2.length()</code>；</li><li><code>dp[i][j]</code>：text1[0:i-1]子串以及text2[0:j-1]子串之间最长公共子串的长度。</li><li>更新规则（对text1的每一个位置 - i-1，遍历text2所有的位置 - j-1）：<ol><li>当<code>text1[i-1] == text2[j-1]</code>：<code>dp[i][j] = dp[i-1][j-1] + 1;</code></li><li>否则： <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</code></li></ol></li></ol><p>最终结果即为 <code>dp[text1.length()][text2.length()]</code>。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(text1.length()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(text2.length()+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3311/" target="_blank" rel="noopener">Longest Common Subsequence</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-26 Longest Common Subsequence
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-25</title>
    <link href="https://karlszp.github.io/2020/04/25/leetcode-day-25/"/>
    <id>https://karlszp.github.io/2020/04/25/leetcode-day-25/</id>
    <published>2020-04-25T10:41:16.000Z</published>
    <updated>2020-04-25T10:41:30.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-25"><a href="#LeetCode-30-days-Challenge-Day-25" class="headerlink" title="LeetCode 30 days Challenge - Day 25"></a>LeetCode 30 days Challenge - Day 25</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定只含有非负元素的整型数组，从第一个位置开始，每一个元素值代表在该位置能够跳跃到达的最远距离，判断给定的数组能否依照规则到达最后一个位置。</p><p>解法：</p><p>本题采用双指针思想，尽可能优化了时间复杂度。</p><p>以下简述双指针的方案：</p><ol><li>首先，对于<code>左指针 l</code>，<code>右指针 r</code>，每次进入while循环体，我们将检测两个指针之间的所有位置，看看这些位置有没有可能跳转到最后一个位置，若能，则返回<code>true</code>。</li><li>假设不能，那么我们需要更新两个指针，且<code>尽可能使两个指针移动的足够快</code>：<ol><li><code>l = r + 1</code>：左指针的更新发生在本次检测之后，我们期望<code>不要进行重复的检测来优化时间</code>，那么左指针将更新为<code>本次检测的最后一个位置的后一个位置</code>。</li><li><code>r = nextr</code>：在检测两个指针中间位置过程中，将能到达的最远位置，更新给<code>nextr</code>，<code>nextr</code>用于记录下一次while循环应该检测的右指针位置。</li></ol></li></ol><p>注：参考上方第二个示例的情况，若对while循环不加退出条件，l、r将会一直为(3, 3)；为避免陷入死循环，检测到两次循环的左右指针全部未改变时，提前退出。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n = nums.size() - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, nextr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nextr = nums[r] ? r + <span class="number">1</span> : r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> nextr = max(nextr, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        l = r+<span class="number">1</span>;</span><br><span class="line">        r = nextr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (l != r+<span class="number">1</span> || r != nextr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3310/" target="_blank" rel="noopener">Jump Game</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-25 Jump Game
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-24</title>
    <link href="https://karlszp.github.io/2020/04/25/leetcode-day-24/"/>
    <id>https://karlszp.github.io/2020/04/25/leetcode-day-24/</id>
    <published>2020-04-25T03:50:31.000Z</published>
    <updated>2020-04-25T03:51:01.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-24"><a href="#LeetCode-30-days-Challenge-Day-24" class="headerlink" title="LeetCode 30 days Challenge - Day 24"></a>LeetCode 30 days Challenge - Day 24</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：要求设计一个缓存机制，并实现访问get操作、put插入操作。</p><ol><li><code>get操作</code>：当元素不存在，返回<code>-1</code>。</li><li><code>put操作</code>：当占满空间后再次插入内容时，将最近最少使用的元素删去，替换之。</li></ol><p>解法：</p><p>本题的朴素解法较简单，本文介绍一种O(1)访存的设计：双向链表（带头尾指针）+ 哈希结构（键值-&gt;链表结点）</p><p>先分析，该设计如何实现O(1)的访存要求：</p><ol><li><p>get操作：按照键值访问哈希表是O(1)的，找到哈希表对应的元素后，访问结点的val元素即可。</p></li><li><p>put操作：</p><ol><li><p>检测是否已存在该键值（unordered_map的find函数实现如下，是O(1)的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</span><br><span class="line">       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;::</span><br><span class="line">    find(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span></span><br><span class="line">    -&gt; const_iterator</span><br><span class="line">    &#123;</span><br><span class="line">      __hash_code __code = <span class="keyword">this</span>-&gt;_M_hash_code(__k);</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> __n = _M_bucket_index(__k, __code);</span><br><span class="line">      __node_type* __p = _M_find_node(__n, __k, __code);</span><br><span class="line">      <span class="keyword">return</span> __p ? const_iterator(__p) : end();</span><br></pre></td></tr></table></figure></li><li><p>检测缓存是否已满是O(1)的。</p></li><li><p>在哈希表中删除（erase）是O(1)的。</p></li><li><p>在链表尾部删除结点、头部插入结点也是O(1)的。</p></li></ol></li></ol><p>综上，能保证是O(1)的访存。</p><p>接下来介绍实现中需要注意的几点：</p><ol><li>删除LRU数据时依据是：通过双向链表尾结点的前一个结点，确定哈希表应该删除哪一表项。因此，链表结点除了记录数据之外，还要记录键值。<code>m.erase(m.find(rear-&gt;pre-&gt;key)); // 哈希表的删除语句</code></li><li>put操作需要进行的判断有三种情况，勿遗漏：<ol><li>缓存已满，插入的键值不存在：删除LRU，在头部插入新键值对（结点）。</li><li>插入的键值已存在，此时不需考虑缓存是否已满：查找键值对应数据，更新为新值，并移动到头部。</li><li>插入的键值不存在，缓存未满的情况：直接在同步插入新键值对（结点）。</li></ol></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双向链表结点定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : key(x), val(y), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cap;<span class="comment">// 容量</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 头指针</span></span><br><span class="line">    ListNode* rear =  <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 尾指针</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;<span class="comment">// 哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动结点到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move2front</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除LRU</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeLRU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = rear-&gt;pre;</span><br><span class="line">        rear-&gt;pre = tmp-&gt;pre;</span><br><span class="line">        tmp-&gt;pre-&gt;next = rear;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在头部插入新结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = <span class="keyword">new</span> ListNode(key, val);</span><br><span class="line">        tmp-&gt;next = head-&gt;next;</span><br><span class="line">        tmp-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = tmp;</span><br><span class="line">        head-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 访问操作</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">            <span class="keyword">return</span> m[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put 插入键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) == m.end() &amp;&amp; m.size() == cap) &#123;</span><br><span class="line">            m.erase(m.find(rear-&gt;pre-&gt;key));</span><br><span class="line">            removeLRU();</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            m[key]-&gt;val = value;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3309/" target="_blank" rel="noopener">LRU Cache</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-24 LRU Cache
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-23</title>
    <link href="https://karlszp.github.io/2020/04/23/leetcode-day-23/"/>
    <id>https://karlszp.github.io/2020/04/23/leetcode-day-23/</id>
    <published>2020-04-23T09:12:27.000Z</published>
    <updated>2020-04-23T09:13:04.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-23"><a href="#LeetCode-30-days-Challenge-Day-23" class="headerlink" title="LeetCode 30 days Challenge - Day 23"></a>LeetCode 30 days Challenge - Day 23</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,7]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整数m和一个整数n，m小于等于n，求将从n到m这些数的按位与的结果。</p><p>解法：</p><p>本题乍一看可以直接模拟，但是由于数字范围很大，模拟的开销太高，会TLE。</p><p>这里介绍一种做法：</p><p>首先观察：</p><p>0    0 0 0 0</p><p>1    0 0 0 1</p><p>2    0 0 1 0</p><p>3    0 0 1 1</p><p>4    0 1 0 0</p><p>5    0 1 0 1</p><p>6    0 1 1 0</p><p>7    0 1 1 1</p><p>8    1 0 0 0</p><p>这次0 - 8数字的二进制表示，可以看到，从右往左<code>第 i 位</code>的规律是：从0开始，0重复 2^i-1^ 次，1重复 2^i-1^ 次，一直这样循环下去。</p><p>再考虑与运算的特点：所有参加运算的数字中，出现了一个0，则结果就一定为0，这是显然的。</p><p>那么，问题转化为：<code>如何判断m到n之间，每个比特位是否出现0？</code></p><ol><li>从右往左，先确定当前<code>循环节长度的一半</code>：<code>power = 1</code>(2^0^)，每向左一位，<code>power *= 2</code>，注意不要爆INT。</li><li>确定循环节长度的一半后，对数字 k，<code>k / power</code>(2^i^)有以下情况：<ol><li>为奇数：那么k的二进制表示、从右往左第 i 位为 1；</li><li>为偶数：那么k的二进制表示、从右往左第 i 位为 0；</li></ol></li><li>有了以上的结论后，结合题目给出的m、n考虑，对第 i 位，m / power以及n / power 有以下情况：<ol><li>奇 + 奇，且为同一个奇数：m到n，第 i 位，全是 1，该位置需要记入结果，<code>res += power</code>；</li><li>奇 + 奇，但为不同的奇数：m到n，第 i 位，两个1中间存在0，该位置不需要记入结果；</li><li>奇 + 偶 / 偶 + 奇 /偶 + 偶：出现偶数，第 i 位存在 0，该位置不需要记入结果；</li></ol></li></ol><p>注：</p><ol><li>注意while循环退出条件：当m小于power即可退出，因为m小于power，那么m表示为二进制表示后，power对应的那一位为0，不需要计入结果了。</li><li>注意power倍增不能爆INT，当power为2^30^次幂的时候，需要检测判断，并赋值为INT_MAX，直接乘2会导致爆INT：INT_MAX = 2^31^ - 1 &lt; 2^31^</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (power &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m / power) % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; (m / power) == (n / power)) &#123;</span><br><span class="line">                res += power;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (power == INT_MAX/<span class="number">2</span> + <span class="number">1</span>) power = INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> power *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3308/" target="_blank" rel="noopener">Bitwise AND of Numbers Range</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-23 Bitwise AND of Numbers Range
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-22</title>
    <link href="https://karlszp.github.io/2020/04/22/leetcode-day-22/"/>
    <id>https://karlszp.github.io/2020/04/22/leetcode-day-22/</id>
    <published>2020-04-22T09:16:35.000Z</published>
    <updated>2020-04-22T09:19:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-22"><a href="#LeetCode-30-days-Challenge-Day-22" class="headerlink" title="LeetCode 30 days Challenge - Day 22"></a>LeetCode 30 days Challenge - Day 22</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a>Subarray Sum Equals K</h2><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组、一个整数k，求数组中所有和为k的子数组个数。</p><p>解法：</p><p><em>本题暴力解法、求累计值再遍历的O(n^2^)解法较简单，可以参考原题讨论区，本文主要就介绍O(n)的做法。</em></p><p>首先考虑该式：<code>前 i 项和 - 前 j 项和 = i 到 j 的和（i &gt; j）</code>；实际任务即：找到所有满足<code>i 到 j 的和</code>等于<code>k</code>的子数组。</p><p>根据该思想，在遍历数组<code>nums</code>的过程中，假设当前位置为<code>i</code>，执行<code>nums[i] += nums[i-1]</code>，迭代来看，<code>nums[i]</code>即为<code>前 i 项和</code>。根据等式性质，只要检测<code>nums[i] - k</code>（即<code>nums[j]</code>）是否在之前出现过，就能确定是否存在子数组。</p><p>我们使用一个哈希结构来存储 <code>前 i 项和</code>出现的次数，这样就能在一次遍历的过程中，O(1)时间找到答案。</p><p>具体操作如下：</p><ol><li>进入循环，遍历nums；</li><li>当累加后，如果当前值为k，说明从0到该位置的子数组满足条件，结果加1；</li><li>在哈希表中查找 nums[i] - k：<code>m.find(nums[i] - k) != m.end()</code>，unordered_map的find方法，当键不存在时，返回位置end()；</li><li>将当前nums[i]的值存入哈希表中，若已存在则加1：m[key]保存key出现的次数。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">        res += nums[i] == k;</span><br><span class="line">        <span class="keyword">if</span> (m.find(nums[i] - k) != m.end()) res += m[nums[i] - k];</span><br><span class="line">        m[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3307/" target="_blank" rel="noopener">Subarray Sum Equals K</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-22 Subarray Sum Equals K
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-21</title>
    <link href="https://karlszp.github.io/2020/04/21/leetcode-day-21/"/>
    <id>https://karlszp.github.io/2020/04/21/leetcode-day-21/</id>
    <published>2020-04-21T09:23:21.000Z</published>
    <updated>2020-04-21T09:23:42.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-21"><a href="#LeetCode-30-days-Challenge-Day-21" class="headerlink" title="LeetCode 30 days Challenge - Day 21"></a>LeetCode 30 days Challenge - Day 21</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Leftmost-Column-with-at-Least-a-One"><a href="#Leftmost-Column-with-at-Least-a-One" class="headerlink" title="Leftmost Column with at Least a One"></a>Leftmost Column with at Least a One</h2><p><em>(This problem is an <strong>interactive problem</strong>.)</em></p><p>A binary matrix means that all elements are <code>0</code> or <code>1</code>. For each <strong>individual</strong> row of the matrix, this row is sorted in non-decreasing order.</p><p>Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a <code>1</code> in it. If such index doesn’t exist, return <code>-1</code>.</p><p><strong>You can’t access the Binary Matrix directly.</strong> You may only access the matrix using a <code>BinaryMatrix</code> interface:</p><ul><li><code>BinaryMatrix.get(x, y)</code> returns the element of the matrix at index <code>(x, y)</code> (0-indexed).</li><li><code>BinaryMatrix.dimensions()</code> returns a list of 2 elements <code>[n, m]</code>, which means the matrix is <code>n * m</code>.</li></ul><p>Submissions making more than <code>1000</code> calls to <code>BinaryMatrix.get</code> will be judged <em>Wrong Answer</em>. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p><p>For custom testing purposes you’re given the binary matrix <code>mat</code> as input in the following four examples. You will not have access the binary matrix directly. </p><p><strong>Example 1:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[1,1]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0,0,1],[0,0,1,1],[0,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= mat.length, mat[i].length &lt;= 100</code></li><li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li><li><code>mat[i]</code> is sorted in a non-decreasing way.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：本题的解释较为生涩，简单来说：给定一个n x m的、只含有0或1的数组，找到其中含有1的、最左边的列，该数组每一行按照非降序排列。</p><p>解法：</p><p>暴力搜索复杂度是O(nm)，采用二分降到O(nlogm)。</p><p>具体实现思想如下：</p><ol><li>对每一列，使用变量flag（初始化为0）检测是否含有1：flag大于0则含有，反之不含有。</li><li>对每一行，使用二分搜索，且注意每一行中1总在0的右边出现（题示：每一行非降序排列），为找到<code>最左边</code>的列，遵守以下规则：<ol><li>若mid列含有1，记录之，并且尝试寻找更左边的一列：<code>r = mid</code>；</li><li>若mid列不含有1，则尝试寻找更右边的一列：<code>l = mid + 1</code>；</li></ol></li></ol><p>最后，当<code>l == r</code>退出时，检测res是否为-1（初始化值），若仍为-1，则需要对第 <code>l</code> 列再次进行检测。</p><p>注：解释一下为什么只有为-1时需要检测：</p><ol><li>退出时若res已经不为-1，则是通过规则1达到退出条件，说明正在尝试寻找“更左边”的一列，然而此时已经不存在更左边的合格列了，则无需检测。</li><li>若仍为-1，说明正在通过规则2尝试寻找合法列，退出循环后需要进行检测看看最后是否找到。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = binaryMatrix.dimensions()[<span class="number">0</span>], m = binaryMatrix.dimensions()[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>, res = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, mid);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;res = mid; r = mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? l : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306/" target="_blank" rel="noopener">Leftmost Column with at Least a One</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-21 Leftmost Column with at Least a One
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-20</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-20/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-20/</id>
    <published>2020-04-20T08:45:24.000Z</published>
    <updated>2020-04-20T08:45:55.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-20"><a href="#LeetCode-30-days-Challenge-Day-20" class="headerlink" title="LeetCode 30 days Challenge - Day 20"></a>LeetCode 30 days Challenge - Day 20</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Construct Binary Search Tree from Preorder Traversal"></a>Construct Binary Search Tree from Preorder Traversal</h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p><p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt;</code> <code>node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt;</code> <code>node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt="img" style="zoom:50%;" /><p><strong>Note:</strong> </p><ol><li><code>1 &lt;= preorder.length &lt;= 100</code></li><li>The values of <code>preorder</code> are distinct.</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个二叉搜索树的前序遍历序列，要求还原该二叉树。</p><p>解法：</p><p>本题只要了解：</p><ol><li>二叉搜索树的特性：<ol><li>对任意结点，其结点值永远满足（如果存在）：<code>左儿子 &lt; 根 &lt; 右儿子</code>；</li><li>由此推出，<code>左子树任意值 &lt; 根 &lt; 右子树任意值</code>；</li></ol></li><li>前序遍历：<code>根 -&gt; 左 -&gt; 右</code> 顺序进行遍历。</li></ol><p>由此，总结还原的思想是：</p><ol><li>对当前序列，第一个值是根结点，剩余序列中，比第一个值小的是左子树，剩余为右子树。</li><li>递归操作即可，当序列只有一个元素时，直接返回。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r &amp;&amp; preorder[i] &lt; root-&gt;val) i++;</span><br><span class="line">    root-&gt;left = (i == l + <span class="number">1</span>) ? <span class="literal">NULL</span> : build(preorder, l + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = (i &gt; r) ? <span class="literal">NULL</span> : build(preorder, i, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3305/" target="_blank" rel="noopener">Construct Binary Search Tree from Preorder Traversal</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-20 Construct Binary Search Tree from Preorder Traversal
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-19</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-19/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-19/</id>
    <published>2020-04-20T03:22:53.000Z</published>
    <updated>2020-04-20T03:39:18.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-19"><a href="#LeetCode-30-days-Challenge-Day-19" class="headerlink" title="LeetCode 30 days Challenge - Day 19"></a>LeetCode 30 days Challenge - Day 19</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个经过“旋转”的升序排列数组，在其中查找<code>target</code>，若不存在返回<code>-1</code>。</p><p>解法：</p><p>本题有多种解法，作者选用的是一种比较直观的方法，其他更为“tricky”的题解可参考原题讨论区。</p><p>思路大体上分为两步：</p><ol><li>二分搜索，找到原升序排列数组第一个元素在给定数组中的位置<code>sep</code>。</li><li>通过映射，将给定数组的元素位置“映射”到实际位置：<code>true_pos = (pos + sep) % nums.size()</code></li><li>在此基础上，进行二分搜索。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, sep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    sep = l;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mapped_mid = (mid + sep) % nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums[mapped_mid] == target) <span class="keyword">return</span> mapped_mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mapped_mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3304/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-19 Search in Rotated Sorted Array
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-18</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-18/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-18/</id>
    <published>2020-04-20T03:22:51.000Z</published>
    <updated>2020-04-20T03:23:10.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-18"><a href="#LeetCode-30-days-Challenge-Day-18" class="headerlink" title="LeetCode 30 days Challenge - Day 18"></a>LeetCode 30 days Challenge - Day 18</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h2><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个m x n的数组，每个元素代表该位置的路径代价，只能向下或向右移动，计算从左上角到右下角的最小代价路径。</p><p>解法：</p><p>非常简单的动态规划思想：</p><ol><li>对每个位置，只能从上方或左边到来。</li><li>对第一行、第一列的位置，只能从左边、上方到来。</li><li>对其他位置，将路径代价从左到右、从上到下地更新为 <code>该位置代价 + min(上方代价，左边代价)</code> 即可。</li></ol><p>最后，右下角元素的值即为最小代价路径。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid.back().back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3303/" target="_blank" rel="noopener">Minimum Path Sum</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-18 Minimum Path Sum
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-17</title>
    <link href="https://karlszp.github.io/2020/04/17/leetcode-day-17/"/>
    <id>https://karlszp.github.io/2020/04/17/leetcode-day-17/</id>
    <published>2020-04-17T08:28:12.000Z</published>
    <updated>2020-04-17T08:28:38.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-17"><a href="#LeetCode-30-days-Challenge-Day-17" class="headerlink" title="LeetCode 30 days Challenge - Day 17"></a>LeetCode 30 days Challenge - Day 17</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只含有字符<code>0</code>和<code>1</code>的二维数组，其中0代表海洋、1代表陆地，<code>连接在一起</code>的陆地构成一座<code>岛屿</code>，求地图中岛屿的个数。</p><p>解法：</p><p>典型的DFS或BFS问题，本题中可以直接修改grid值，在访问过陆地(1)之后可以将之修改为海洋(0)，无需额外设立一个访问数组。</p><p>具体过程如下：</p><ol><li>新建一个变量nums记录岛屿数。</li><li>遍历整个数组，遇到为<code>陆地</code>的元素时，以该元素位置为起点进行深度优先搜索，确保其所在岛屿所有的陆地都被访问到并且修改为海洋。</li></ol><p>因为每次访问都保证其所在岛屿所有的陆地都被访问到并且修改为海洋，所以遇到新的陆地时将nums加1。</p><p>注：本题所给的grid数组是<code>char 字符型</code>数组！进行判断时候不可以写<code>if (grid[i][j])</code>而要写<code>if (grid[i][j]==&#39;1&#39;)</code>。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;grid.size()<span class="number">-1</span> || y&lt;<span class="number">0</span> || y&gt;grid[<span class="number">0</span>].size()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[x][y]==<span class="string">'1'</span>) &#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) dfs(x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>], grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                nums++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3302/" target="_blank" rel="noopener">Number of Islands</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-17 Number of Islands
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-16</title>
    <link href="https://karlszp.github.io/2020/04/16/leetcode-day-16/"/>
    <id>https://karlszp.github.io/2020/04/16/leetcode-day-16/</id>
    <published>2020-04-16T09:07:24.000Z</published>
    <updated>2020-04-16T09:07:44.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-16"><a href="#LeetCode-30-days-Challenge-Day-16" class="headerlink" title="LeetCode 30 days Challenge - Day 16"></a>LeetCode 30 days Challenge - Day 16</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Valid-Parenthesis-String"><a href="#Valid-Parenthesis-String" class="headerlink" title="Valid Parenthesis String"></a>Valid Parenthesis String</h2><p>Given a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules:</p><ol><li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li><li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li><li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li><li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string.</li><li>An empty string is also valid.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*)&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*))&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The string size will be in the range [1, 100].</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个包含左右圆括号以及星号的字符串，其中星号可以视为左右圆括号或者空字符串，判断该字符串是否符合规范。</p><p>解法：</p><p>本题乍一看像栈结构的经典例题，但本题引入了<code>*</code>号的特殊性，带来了一定难度。</p><p>首先考虑，<code>*</code>的引入带来的影响：</p><ol><li>假若视为 <code>(</code>，那么需要一个额外的 <code>)</code> 进行匹配。</li><li>假若视为 <code>)</code>，那么能额外匹配一个位置在其之前的 <code>(</code> 。</li><li>假若视为空，那么没有影响。</li></ol><p>由于一个符合规范的序列，<code>(</code>往往先于<code>)</code>出现，因此可以考虑 <code>*</code> 的不同取值，对需要的 <code>)</code> 数量的影响。</p><p>假设，最少需要min_num个 <code>)</code>，最多需要max_num个 <code>)</code>，问题转化为 <code>*</code> 的不同取值，对上述两个变量的影响：</p><ol><li>遇到 <code>(</code>：min_num、max_num都增加1，这是显然的。</li><li>遇到 <code>)</code>：<ol><li>max_num减少1，这也是显然的；</li><li>min_num也减少1，但不少于0（右括号只能匹配其左边的左括号，如果min_num减少成负数，相当于之后的右括号匹配了之前的左括号，是不符合常理的）。</li></ol></li><li>遇到 <code>*</code>：<ol><li>因为可以看成一个 <code>(</code>，max_num增加1；</li><li>也可以看成一个 <code>)</code>，min_num也减少1，但不少于0（理由同上）。</li><li>看成空串则不会造成影响。</li></ol></li></ol><p>在遍历过程中，若出现max_num小于0的情况，即出现了一个无法匹配的右括号，直接返回 <code>false</code>。</p><p>最后，因为min_num是最少需要的条件，判断min_num是否为0即可。</p><p>注：本题较难理解的是min_num在遍历过程中不能小于0的原因：小于0则相当于某一个左括号之后的右括号匹配了该左括号，是不符合常理的，这两个括号就是这种情况“ )( ”。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_num = <span class="number">0</span>, max_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            min_num++;</span><br><span class="line">            max_num++;                    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num--;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3301/" target="_blank" rel="noopener">Valid Parenthesis String</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-16 Valid Parenthesis String
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-14</title>
    <link href="https://karlszp.github.io/2020/04/14/leetcode-day-14/"/>
    <id>https://karlszp.github.io/2020/04/14/leetcode-day-14/</id>
    <published>2020-04-14T14:47:45.000Z</published>
    <updated>2020-04-14T15:10:26.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-14"><a href="#LeetCode-30-days-Challenge-Day-14" class="headerlink" title="LeetCode 30 days Challenge - Day 14"></a>LeetCode 30 days Challenge - Day 14</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Perform-String-Shifts"><a href="#Perform-String-Shifts" class="headerlink" title="Perform String Shifts"></a>Perform String Shifts</h2><p>You are given a string <code>s</code> containing lowercase English letters, and a matrix <code>shift</code>, where <code>shift[i] = [direction, amount]</code>:</p><ul><li><code>direction</code> can be <code>0</code> (for left shift) or <code>1</code> (for right shift). </li><li><code>amount</code> is the amount by which string <code>s</code> is to be shifted.</li><li>A left shift by 1 means remove the first character of <code>s</code> and append it to the end.</li><li>Similarly, a right shift by 1 means remove the last character of <code>s</code> and add it to the beginning.</li></ul><p>Return the final string after all operations.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, shift &#x3D; [[0,1],[1,2]]</span><br><span class="line">Output: &quot;cab&quot;</span><br><span class="line">Explanation: </span><br><span class="line">[0,1] means shift to left by 1. &quot;abc&quot; -&gt; &quot;bca&quot;</span><br><span class="line">[1,2] means shift to right by 2. &quot;bca&quot; -&gt; &quot;cab&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcdefg&quot;, shift &#x3D; [[1,1],[1,1],[0,2],[1,3]]</span><br><span class="line">Output: &quot;efgabcd&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">[1,1] means shift to right by 1. &quot;abcdefg&quot; -&gt; &quot;gabcdef&quot;</span><br><span class="line">[1,1] means shift to right by 1. &quot;gabcdef&quot; -&gt; &quot;fgabcde&quot;</span><br><span class="line">[0,2] means shift to left by 2. &quot;fgabcde&quot; -&gt; &quot;abcdefg&quot;</span><br><span class="line">[1,3] means shift to right by 3. &quot;abcdefg&quot; -&gt; &quot;efgabcd&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> only contains lower case English letters.</li><li><code>1 &lt;= shift.length &lt;= 100</code></li><li><code>shift[i].length == 2</code></li><li><code>0 &lt;= shift[i][0] &lt;= 1</code></li><li><code>0 &lt;= shift[i][1] &lt;= 100</code></li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个原始字符串以及一个位移指令集合shift，shift数组中，每个元素是一个二元组，依次表示对字符串进行的位移操作方向以及位数，要求返回最后处理完成的字符串。</p><p>解法：</p><p>本题提示中，说明了在限制条件下，直接暴力模拟也能通过，但这肯定不是我们想要的答案，为了尽可能减少“移动”操作，先来分析移动操作的特点：</p><ol><li>方向0：向左移动amount个元素，实际上是将<code>前amount个元素移动到字符串尾部</code>。</li><li>方向1：向右移动amount个元素，实际上是将<code>后amount个元素移动到字符串头部</code>。</li></ol><p>两次方向不同、amount相同的移动，将相互抵消：<code>abcd -0,2-&gt; cdab -1,2-&gt; abcd</code>。</p><p>由此，推断出最便利的做法是，先遍历shift数组，记录最终需要移动的步数（final_amount），具体措施：</p><ol><li>遇到方向0，final_amount减去对应amount；</li><li>遇到方向1，final_amount加上对应amount；</li></ol><p>最后，根据final_amount的正负（注意对长度取模，长度为n的字符串移动n次将恢复原状），依据移动操作的特点进行处理即可。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stringShift</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; shift)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> final_amount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : shift) final_amount += v[<span class="number">0</span>] ? v[<span class="number">1</span>] : -v[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (final_amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        final_amount %= s.length();</span><br><span class="line">        res = s.substr(<span class="number">0</span>, s.length() - final_amount);</span><br><span class="line">        res = s.substr(s.length() - final_amount) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        final_amount = (-final_amount) % s.length();</span><br><span class="line">        res = s.substr(final_amount);</span><br><span class="line">        res += s.substr(<span class="number">0</span>, final_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3299/" target="_blank" rel="noopener">Perform String Shifts</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-14 Perform String Shifts
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-13</title>
    <link href="https://karlszp.github.io/2020/04/13/leetcode-day-13/"/>
    <id>https://karlszp.github.io/2020/04/13/leetcode-day-13/</id>
    <published>2020-04-13T08:04:47.000Z</published>
    <updated>2020-04-13T08:05:31.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-13"><a href="#LeetCode-30-days-Challenge-Day-13" class="headerlink" title="LeetCode 30 days Challenge - Day 13"></a>LeetCode 30 days Challenge - Day 13</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a>Contiguous Array</h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只包含0或1的数组，求满足条件（子数组中0和1数量相等）的最长连续子数组的长度。</p><p>解法：</p><p>本题关键是遍历数组，确保不漏掉符合条件的子数组，并更新最大长度。</p><p>这里为了减少空间复杂度，使用哈希结构建立count（初始为0，遇0减1，遇1加1）到pos（count第一次出现的位置）的映射：</p><ol><li>初始化res为最大长度，count为当前1和0的个数差，负数表示0比1多。</li><li>建立映射，初始化<code>m[0] = -1</code>的意义是：无论第一个元素是0还是1，count都将变为非0，因此，count=0首次出现的位置实际上是<code>-1</code>处（不存在，只是虚拟出一个位置，以保证当最长子数组包含第一个元素的时候，能正确计算长度）。</li><li>在遍历过程中：<ol><li>当<code>m.find(count) == m.end()</code>即新的count值首次出现，记录其位置。</li><li>反之，更新res为较大值。</li></ol></li></ol><p>以下提供参考图片供读者理解：</p><p><img src="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/Figures/535_Contiguous_Array.PNG" alt=""></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        count += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.find(count) == m.end()) m[count] = i;</span><br><span class="line">        <span class="keyword">else</span> res = max(res, i - m[count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3298/" target="_blank" rel="noopener">Contiguous Array</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-13 Contiguous Array
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-12</title>
    <link href="https://karlszp.github.io/2020/04/12/leetcode-day-12/"/>
    <id>https://karlszp.github.io/2020/04/12/leetcode-day-12/</id>
    <published>2020-04-12T08:33:12.000Z</published>
    <updated>2020-04-12T08:33:40.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-12"><a href="#LeetCode-30-days-Challenge-Day-12" class="headerlink" title="LeetCode 30 days Challenge - Day 12"></a>LeetCode 30 days Challenge - Day 12</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Last-Stone-Weight"><a href="#Last-Stone-Weight" class="headerlink" title="Last Stone Weight"></a>Last Stone Weight</h2><p>We have a collection of stones, each stone has a positive integer weight.</p><p>Each turn, we choose the two <strong>heaviest</strong> stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p><ul><li>If <code>x == y</code>, both stones are totally destroyed;</li><li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li></ul><p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整形数组，每个值代表一颗石子的质量。每次选取质量最大的两颗石子（如果存在至少两颗石子），若两颗石子质量相等，则进行下一次选取；否则，将一颗质量为它们的质量差的石子加入数组中。</p><p>解法：</p><p>简单进行模拟，重点注意每次需要选取质量最大的两颗，而且新加入石子后影响原有顺序，考虑使用大顶堆进行存储，作者采用的是STL中大顶堆实现的优先队列<code>&lt;priority_queue&gt;</code>。</p><p>确定了储存结构，模拟操作如下：</p><ol><li>首先遍历数组，将“石子”加入优先队列。</li><li>根据题目要求，当剩余石子为1颗或0颗时，结束循环，否则：<ol><li>取队首元素，赋值给y，并将之出队；</li><li>再次取队首元素，赋值给x，并将之出队；</li><li>由于是优先队列，y &gt;= x，因此只需比较x是否与y相等：<ol><li>相等：不进行操作，相当于两颗石子抵消了。</li><li>不相等：将质量差值y-x加入优先队列。</li></ol></li></ol></li><li>最后判断队列是否为空即可，</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : stones) pq.push(i);</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">int</span> x = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (x != y) pq.push(y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.empty() ? <span class="number">0</span> : pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3297/" target="_blank" rel="noopener">Last Stone Weight</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-12 Last Stone Weight
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-11</title>
    <link href="https://karlszp.github.io/2020/04/11/leetcode-day-11/"/>
    <id>https://karlszp.github.io/2020/04/11/leetcode-day-11/</id>
    <published>2020-04-11T08:36:20.000Z</published>
    <updated>2020-04-11T08:47:08.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-11"><a href="#LeetCode-30-days-Challenge-Day-11" class="headerlink" title="LeetCode 30 days Challenge - Day 11"></a>LeetCode 30 days Challenge - Day 11</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵二叉树，要求找到它的直径。二叉树直径定义为其中距离最远的两个节点之间的距离。</p><p>解法：</p><p>由题，我们知道直径不一定经过当前树的根结点。</p><p>因此，对以当前结点为根结点的（子）树，根据是否经过其根结点，可以分为两种情况，递归思想如下：</p><ol><li>对于非空结点，计算：<ol><li>左子树的深度 + 右子树的深度 = <strong>经过</strong>当前结点的最长距离；</li><li>左子树的直径（递归，不经过根结点）；</li><li>右子树的直径（递归，不经过根结点）；</li></ol></li><li>对以上三值，取最大值即为以当前结点为根的二叉树的直径。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(getdepth(root-&gt;left), getdepth(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = getdepth(root-&gt;left) + getdepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> max(cur, max(diameterOfBinaryTree(root-&gt;left), diameterOfBinaryTree(root-&gt;right)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3293/" target="_blank" rel="noopener">Diameter of Binary Tree</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-11 Diameter of Binary Tree
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-10</title>
    <link href="https://karlszp.github.io/2020/04/10/leetcode-day-10/"/>
    <id>https://karlszp.github.io/2020/04/10/leetcode-day-10/</id>
    <published>2020-04-10T08:51:52.000Z</published>
    <updated>2020-04-10T08:52:46.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-10"><a href="#LeetCode-30-days-Challenge-Day-10" class="headerlink" title="LeetCode 30 days Challenge - Day 10"></a>LeetCode 30 days Challenge - Day 10</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个最小栈，包括压栈、退栈、返回最小值等函数。</p><p>解法：</p><p>最小栈结构为了记录最小值，需要多使用一个栈来记录最小值。</p><p>接下来，讨论各个方法如何实现：</p><ol><li><p>push() 压栈：</p><ol><li><p>首先，无论如何将数据压入数据栈；</p></li><li><p>接着进行判断，若最小栈栈顶元素大于或等于压入的数据，将该数据压入最小栈。</p><p>（此处注意，等于的情况也要压栈，这样才能避免退栈操作在多个最小值删除。）</p></li></ol></li><li><p>pop() 出栈：</p><ol><li><p>首先，若最小栈栈顶元素等于当前栈顶元素，将最小栈栈顶元素弹出。</p><p>（此处注意push操作中第二步的注释。）</p></li><li><p>将栈顶元素出栈。</p></li></ol></li><li><p>top() 访问栈顶元素：调用vector结构的back()方法。</p></li><li><p>getMin() 访问最小值：调用stack结构的top()方法。</p></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ministack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        ministack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ministack.top()) ministack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.back() == ministack.top()) ministack.pop();</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ministack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3292/" target="_blank" rel="noopener">Min Stack</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-10 Min Stack
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
