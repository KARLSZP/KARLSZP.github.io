<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Karl&#39;s Nest</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://karlszp.github.io/"/>
  <updated>2020-04-28T14:24:30.311Z</updated>
  <id>https://karlszp.github.io/</id>
  
  <author>
    <name>Karl Szp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-day-28</title>
    <link href="https://karlszp.github.io/2020/04/28/leetcode-day-28/"/>
    <id>https://karlszp.github.io/2020/04/28/leetcode-day-28/</id>
    <published>2020-04-28T14:24:07.000Z</published>
    <updated>2020-04-28T14:24:30.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-28"><a href="#LeetCode-30-days-Challenge-Day-28" class="headerlink" title="LeetCode 30 days Challenge - Day 28"></a>LeetCode 30 days Challenge - Day 28</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="First-Unique-Number"><a href="#First-Unique-Number" class="headerlink" title="First Unique Number"></a>First Unique Number</h2><p>You have a queue of integers, you need to retrieve the first unique integer in the queue.</p><p>Implement the <code>FirstUnique</code> class:</p><ul><li><code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.</li><li><code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.</li><li><code>void add(int value)</code> insert value to the queue. </li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[2,3,5]],[],[5],[],[2],[],[3],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,2,null,2,null,3,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([2,3,5]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(5);            &#x2F;&#x2F; the queue is now [2,3,5,5]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 2</span><br><span class="line">firstUnique.add(2);            &#x2F;&#x2F; the queue is now [2,3,5,5,2]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 3</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [2,3,5,5,2,3]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,-1,null,null,null,null,null,17]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([7,7,7,7,7,7]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3]</span><br><span class="line">firstUnique.add(3);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3]</span><br><span class="line">firstUnique.add(7);            &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7]</span><br><span class="line">firstUnique.add(17);           &#x2F;&#x2F; the queue is now [7,7,7,7,7,7,7,3,3,7,17]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 17</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]</span><br><span class="line">[[[809]],[],[809],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,809,null,-1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique &#x3D; new FirstUnique([809]);</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return 809</span><br><span class="line">firstUnique.add(809);          &#x2F;&#x2F; the queue is now [809,809]</span><br><span class="line">firstUnique.showFirstUnique(); &#x2F;&#x2F; return -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^8</code></li><li><code>1 &lt;= value &lt;= 10^8</code></li><li>At most <code>50000</code> calls will be made to <code>showFirstUnique</code> and <code>add</code>.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个能够返回<code>第一个唯一元素</code>的队列。要求实现：1.返回<code>第一个唯一元素</code>的功能；2. 添加一个新元素。</p><p>解法：</p><p>本题重点需要理清，两个功能在各种不同的情况下，应该如何工作：</p><ol><li><code>showFirstUnique()</code>：<ol><li>当队列为空，或没有唯一元素，返回 <code>-1</code>；</li><li>当队列存在唯一元素，返回第一个唯一的<code>元素值</code>。</li></ol></li><li><code>add(int value)</code>：<ol><li>当队列不存在该元素，那么<code>加入队列</code>。</li><li>当队列存在该元素，那么将<code>原来的元素从队列中移除</code>，并且<code>以后不能在加入该元素</code>。</li></ol></li></ol><p>到这里，逻辑思路就整理完毕，接下来考虑数据结构使用问题。</p><ol><li>为了<code>常量时间</code>访存，使用存在头尾指针的双向链表来存储<code>唯一的元素</code>：<ol><li>每个元素初次出现都加入该链表，当重复的元素出现时，从该表移除，且不再加入该表，所以说存储的是“唯一的”元素。</li><li>第一个唯一元素即为第一个链表元素：<code>head-&gt;next == rear ? -1 : head-&gt;next-&gt;val</code>；此处注意对链表是否为空的判断。</li><li>当通过add加入新元素：新元素通过<code>尾插法</code>加入链表，不会打乱原有的相对顺序。</li><li>当出现重复元素，删除某一节点时：参见代码<code>removeNode(ListNode* node)</code>处。</li></ol></li><li>为了<code>常量时间</code>判断元素存在，建立从value到链表指针的映射<code>unordered_map&lt;int, ListNode*&gt; m</code>：<ol><li>添加一个元素时，通过 <code>m.find(value) != m.end()</code>判断元素是否存在。</li><li>若不存在，新建链表结点、插入链表中、将指针赋给<code>m[value]</code>，这样可以通过常量时间访问到该value对应的链表结点。</li><li>为了实现“<code>以后不能在加入该元素</code>”的功能，当出现重复元素时，从链表中删除原元素后，将<code>m[value]</code>指向<code>NULL</code>，未来再次遇到该元素时就不会再次进行删除元素操作（已经不存在该元素，删除操作会造成错误）。</li></ol></li></ol><p>本题值得细品，勿只读解法，务必参考代码，整理清楚逻辑。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstUnique</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) : val(x), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        rear-&gt;pre-&gt;next = node;</span><br><span class="line">        node-&gt;pre = rear-&gt;pre;</span><br><span class="line">        node-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = node;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* rear = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;</span><br><span class="line"></span><br><span class="line">    FirstUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showFirstUnique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next == rear ? <span class="number">-1</span> : head-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(value) != m.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[value] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                removeNode(m[value]);</span><br><span class="line">                m[value] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(value) == m.end()) &#123;</span><br><span class="line">            ListNode* node = addNode(value);</span><br><span class="line">            m[value] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/" target="_blank" rel="noopener">First Unique Number</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-28 First Unique Number
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-27</title>
    <link href="https://karlszp.github.io/2020/04/27/leetcode-day-27/"/>
    <id>https://karlszp.github.io/2020/04/27/leetcode-day-27/</id>
    <published>2020-04-27T08:21:15.000Z</published>
    <updated>2020-04-27T09:03:37.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-27"><a href="#LeetCode-30-days-Challenge-Day-27" class="headerlink" title="LeetCode 30 days Challenge - Day 27"></a>LeetCode 30 days Challenge - Day 27</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个值为0或1的二维数组，求其中由1组成的、面积最大的正方形面积。</p><p>解法：</p><p>本题使用动态规划思想，其中<code>dp[i][j]</code>记录以i、j为右下角坐标的正方形的最大边长，从左往右，从上往下遍历一遍数组，并记录其中出现过的最大边长，返回结果即为最大边长的平方。</p><p>dp数组按照以下规则进行更新：</p><ol><li>对i，j：满足以i、j为右下角坐标的正方形边长范围是<code>1 - (min(i, j) + 1)</code>，这些边长的正方形中只要有一个元素不为1，则不能加入结果。</li><li>根据动态规划的思想：当前状态只与其上一个状态有关，即对于上述以i、j为右下角坐标的正方形，边长为 <code>(min(i, j) + 1)</code>的正方形就是<code>当前状态</code>，因此需要考虑其<code>上一个状态</code>即边长为<code>min(i, j)</code>的正方形是如何影响当前状态的。</li><li>不难发现，边长为 <code>(min(i, j) + 1)</code>的正方形除去最右下角元素后含有三个边长为<code>min(i, j)</code>的正方形（分别是去除最右列、最下行，去除最右列、最上行，去除最左列、最下行三种情况），当且仅当这三个正方形都全是1、且位置(i, j)也是1时，<code>dp[i][j]</code>取值为<code>(min(i, j) + 1)</code>；</li><li>综上，规则为：<code>dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1</code></li></ol><p>下图展示了遍历过程中三种情况：</p><p><img src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true" alt=""></p><p>注：最终求的是面积，注意返回最大边长的平方。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3312/" target="_blank" rel="noopener">Maximal Square</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-27 Maximal Square
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-26</title>
    <link href="https://karlszp.github.io/2020/04/27/leetcode-day-26/"/>
    <id>https://karlszp.github.io/2020/04/27/leetcode-day-26/</id>
    <published>2020-04-27T08:20:51.000Z</published>
    <updated>2020-04-27T08:21:11.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-26"><a href="#LeetCode-30-days-Challenge-Day-26" class="headerlink" title="LeetCode 30 days Challenge - Day 26"></a>LeetCode 30 days Challenge - Day 26</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h2><p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p><p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p><p>If there is no common subsequence, return 0. </p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= text1.length &lt;= 1000</code></li><li><code>1 &lt;= text2.length &lt;= 1000</code></li><li>The input strings consist of lowercase English characters only.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定两个字符串，求其中最长公共子串的长度。</p><p>解法：</p><p>本题需要注意区分子序列、子串：subsequence是子序列，子序列中各元素不需要连续，substring是子串，子串中每个元素必须是连续的。</p><p>本题是经典的动态规划题，维护一个二维动态规划数组dp，其中：</p><ol><li><code>i：1 - text1.length()</code>；<code>j：1 - text2.length()</code>；</li><li><code>dp[i][j]</code>：text1[0:i-1]子串以及text2[0:j-1]子串之间最长公共子串的长度。</li><li>更新规则（对text1的每一个位置 - i-1，遍历text2所有的位置 - j-1）：<ol><li>当<code>text1[i-1] == text2[j-1]</code>：<code>dp[i][j] = dp[i-1][j-1] + 1;</code></li><li>否则： <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</code></li></ol></li></ol><p>最终结果即为 <code>dp[text1.length()][text2.length()]</code>。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(text1.length()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(text2.length()+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3311/" target="_blank" rel="noopener">Longest Common Subsequence</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-26 Longest Common Subsequence
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-25</title>
    <link href="https://karlszp.github.io/2020/04/25/leetcode-day-25/"/>
    <id>https://karlszp.github.io/2020/04/25/leetcode-day-25/</id>
    <published>2020-04-25T10:41:16.000Z</published>
    <updated>2020-04-25T10:41:30.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-25"><a href="#LeetCode-30-days-Challenge-Day-25" class="headerlink" title="LeetCode 30 days Challenge - Day 25"></a>LeetCode 30 days Challenge - Day 25</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定只含有非负元素的整型数组，从第一个位置开始，每一个元素值代表在该位置能够跳跃到达的最远距离，判断给定的数组能否依照规则到达最后一个位置。</p><p>解法：</p><p>本题采用双指针思想，尽可能优化了时间复杂度。</p><p>以下简述双指针的方案：</p><ol><li>首先，对于<code>左指针 l</code>，<code>右指针 r</code>，每次进入while循环体，我们将检测两个指针之间的所有位置，看看这些位置有没有可能跳转到最后一个位置，若能，则返回<code>true</code>。</li><li>假设不能，那么我们需要更新两个指针，且<code>尽可能使两个指针移动的足够快</code>：<ol><li><code>l = r + 1</code>：左指针的更新发生在本次检测之后，我们期望<code>不要进行重复的检测来优化时间</code>，那么左指针将更新为<code>本次检测的最后一个位置的后一个位置</code>。</li><li><code>r = nextr</code>：在检测两个指针中间位置过程中，将能到达的最远位置，更新给<code>nextr</code>，<code>nextr</code>用于记录下一次while循环应该检测的右指针位置。</li></ol></li></ol><p>注：参考上方第二个示例的情况，若对while循环不加退出条件，l、r将会一直为(3, 3)；为避免陷入死循环，检测到两次循环的左右指针全部未改变时，提前退出。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n = nums.size() - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, nextr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nextr = nums[r] ? r + <span class="number">1</span> : r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> nextr = max(nextr, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        l = r+<span class="number">1</span>;</span><br><span class="line">        r = nextr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (l != r+<span class="number">1</span> || r != nextr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3310/" target="_blank" rel="noopener">Jump Game</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-25 Jump Game
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-24</title>
    <link href="https://karlszp.github.io/2020/04/25/leetcode-day-24/"/>
    <id>https://karlszp.github.io/2020/04/25/leetcode-day-24/</id>
    <published>2020-04-25T03:50:31.000Z</published>
    <updated>2020-04-25T03:51:01.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-24"><a href="#LeetCode-30-days-Challenge-Day-24" class="headerlink" title="LeetCode 30 days Challenge - Day 24"></a>LeetCode 30 days Challenge - Day 24</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：要求设计一个缓存机制，并实现访问get操作、put插入操作。</p><ol><li><code>get操作</code>：当元素不存在，返回<code>-1</code>。</li><li><code>put操作</code>：当占满空间后再次插入内容时，将最近最少使用的元素删去，替换之。</li></ol><p>解法：</p><p>本题的朴素解法较简单，本文介绍一种O(1)访存的设计：双向链表（带头尾指针）+ 哈希结构（键值-&gt;链表结点）</p><p>先分析，该设计如何实现O(1)的访存要求：</p><ol><li><p>get操作：按照键值访问哈希表是O(1)的，找到哈希表对应的元素后，访问结点的val元素即可。</p></li><li><p>put操作：</p><ol><li><p>检测是否已存在该键值（unordered_map的find函数实现如下，是O(1)的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</span><br><span class="line">       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;::</span><br><span class="line">    find(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span></span><br><span class="line">    -&gt; const_iterator</span><br><span class="line">    &#123;</span><br><span class="line">      __hash_code __code = <span class="keyword">this</span>-&gt;_M_hash_code(__k);</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> __n = _M_bucket_index(__k, __code);</span><br><span class="line">      __node_type* __p = _M_find_node(__n, __k, __code);</span><br><span class="line">      <span class="keyword">return</span> __p ? const_iterator(__p) : end();</span><br></pre></td></tr></table></figure></li><li><p>检测缓存是否已满是O(1)的。</p></li><li><p>在哈希表中删除（erase）是O(1)的。</p></li><li><p>在链表尾部删除结点、头部插入结点也是O(1)的。</p></li></ol></li></ol><p>综上，能保证是O(1)的访存。</p><p>接下来介绍实现中需要注意的几点：</p><ol><li>删除LRU数据时依据是：通过双向链表尾结点的前一个结点，确定哈希表应该删除哪一表项。因此，链表结点除了记录数据之外，还要记录键值。<code>m.erase(m.find(rear-&gt;pre-&gt;key)); // 哈希表的删除语句</code></li><li>put操作需要进行的判断有三种情况，勿遗漏：<ol><li>缓存已满，插入的键值不存在：删除LRU，在头部插入新键值对（结点）。</li><li>插入的键值已存在，此时不需考虑缓存是否已满：查找键值对应数据，更新为新值，并移动到头部。</li><li>插入的键值不存在，缓存未满的情况：直接在同步插入新键值对（结点）。</li></ol></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双向链表结点定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : key(x), val(y), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cap;<span class="comment">// 容量</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 头指针</span></span><br><span class="line">    ListNode* rear =  <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 尾指针</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; m;<span class="comment">// 哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        head-&gt;next = rear;</span><br><span class="line">        rear-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动结点到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move2front</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除LRU</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeLRU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = rear-&gt;pre;</span><br><span class="line">        rear-&gt;pre = tmp-&gt;pre;</span><br><span class="line">        tmp-&gt;pre-&gt;next = rear;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在头部插入新结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = <span class="keyword">new</span> ListNode(key, val);</span><br><span class="line">        tmp-&gt;next = head-&gt;next;</span><br><span class="line">        tmp-&gt;pre = head;</span><br><span class="line">        head-&gt;next-&gt;pre = tmp;</span><br><span class="line">        head-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 访问操作</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">            <span class="keyword">return</span> m[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put 插入键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) == m.end() &amp;&amp; m.size() == cap) &#123;</span><br><span class="line">            m.erase(m.find(rear-&gt;pre-&gt;key));</span><br><span class="line">            removeLRU();</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m.find(key) != m.end()) &#123;</span><br><span class="line">            m[key]-&gt;val = value;</span><br><span class="line">            move2front(m[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m[key] = insertNode(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3309/" target="_blank" rel="noopener">LRU Cache</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-24 LRU Cache
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-23</title>
    <link href="https://karlszp.github.io/2020/04/23/leetcode-day-23/"/>
    <id>https://karlszp.github.io/2020/04/23/leetcode-day-23/</id>
    <published>2020-04-23T09:12:27.000Z</published>
    <updated>2020-04-23T09:13:04.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-23"><a href="#LeetCode-30-days-Challenge-Day-23" class="headerlink" title="LeetCode 30 days Challenge - Day 23"></a>LeetCode 30 days Challenge - Day 23</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,7]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整数m和一个整数n，m小于等于n，求将从n到m这些数的按位与的结果。</p><p>解法：</p><p>本题乍一看可以直接模拟，但是由于数字范围很大，模拟的开销太高，会TLE。</p><p>这里介绍一种做法：</p><p>首先观察：</p><p>0    0 0 0 0</p><p>1    0 0 0 1</p><p>2    0 0 1 0</p><p>3    0 0 1 1</p><p>4    0 1 0 0</p><p>5    0 1 0 1</p><p>6    0 1 1 0</p><p>7    0 1 1 1</p><p>8    1 0 0 0</p><p>这次0 - 8数字的二进制表示，可以看到，从右往左<code>第 i 位</code>的规律是：从0开始，0重复 2^i-1^ 次，1重复 2^i-1^ 次，一直这样循环下去。</p><p>再考虑与运算的特点：所有参加运算的数字中，出现了一个0，则结果就一定为0，这是显然的。</p><p>那么，问题转化为：<code>如何判断m到n之间，每个比特位是否出现0？</code></p><ol><li>从右往左，先确定当前<code>循环节长度的一半</code>：<code>power = 1</code>(2^0^)，每向左一位，<code>power *= 2</code>，注意不要爆INT。</li><li>确定循环节长度的一半后，对数字 k，<code>k / power</code>(2^i^)有以下情况：<ol><li>为奇数：那么k的二进制表示、从右往左第 i 位为 1；</li><li>为偶数：那么k的二进制表示、从右往左第 i 位为 0；</li></ol></li><li>有了以上的结论后，结合题目给出的m、n考虑，对第 i 位，m / power以及n / power 有以下情况：<ol><li>奇 + 奇，且为同一个奇数：m到n，第 i 位，全是 1，该位置需要记入结果，<code>res += power</code>；</li><li>奇 + 奇，但为不同的奇数：m到n，第 i 位，两个1中间存在0，该位置不需要记入结果；</li><li>奇 + 偶 / 偶 + 奇 /偶 + 偶：出现偶数，第 i 位存在 0，该位置不需要记入结果；</li></ol></li></ol><p>注：</p><ol><li>注意while循环退出条件：当m小于power即可退出，因为m小于power，那么m表示为二进制表示后，power对应的那一位为0，不需要计入结果了。</li><li>注意power倍增不能爆INT，当power为2^30^次幂的时候，需要检测判断，并赋值为INT_MAX，直接乘2会导致爆INT：INT_MAX = 2^31^ - 1 &lt; 2^31^</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (power &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m / power) % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; (m / power) == (n / power)) &#123;</span><br><span class="line">                res += power;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (power == INT_MAX/<span class="number">2</span> + <span class="number">1</span>) power = INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> power *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3308/" target="_blank" rel="noopener">Bitwise AND of Numbers Range</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-23 Bitwise AND of Numbers Range
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-22</title>
    <link href="https://karlszp.github.io/2020/04/22/leetcode-day-22/"/>
    <id>https://karlszp.github.io/2020/04/22/leetcode-day-22/</id>
    <published>2020-04-22T09:16:35.000Z</published>
    <updated>2020-04-22T09:19:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-22"><a href="#LeetCode-30-days-Challenge-Day-22" class="headerlink" title="LeetCode 30 days Challenge - Day 22"></a>LeetCode 30 days Challenge - Day 22</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a>Subarray Sum Equals K</h2><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整型数组、一个整数k，求数组中所有和为k的子数组个数。</p><p>解法：</p><p><em>本题暴力解法、求累计值再遍历的O(n^2^)解法较简单，可以参考原题讨论区，本文主要就介绍O(n)的做法。</em></p><p>首先考虑该式：<code>前 i 项和 - 前 j 项和 = i 到 j 的和（i &gt; j）</code>；实际任务即：找到所有满足<code>i 到 j 的和</code>等于<code>k</code>的子数组。</p><p>根据该思想，在遍历数组<code>nums</code>的过程中，假设当前位置为<code>i</code>，执行<code>nums[i] += nums[i-1]</code>，迭代来看，<code>nums[i]</code>即为<code>前 i 项和</code>。根据等式性质，只要检测<code>nums[i] - k</code>（即<code>nums[j]</code>）是否在之前出现过，就能确定是否存在子数组。</p><p>我们使用一个哈希结构来存储 <code>前 i 项和</code>出现的次数，这样就能在一次遍历的过程中，O(1)时间找到答案。</p><p>具体操作如下：</p><ol><li>进入循环，遍历nums；</li><li>当累加后，如果当前值为k，说明从0到该位置的子数组满足条件，结果加1；</li><li>在哈希表中查找 nums[i] - k：<code>m.find(nums[i] - k) != m.end()</code>，unordered_map的find方法，当键不存在时，返回位置end()；</li><li>将当前nums[i]的值存入哈希表中，若已存在则加1：m[key]保存key出现的次数。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">        res += nums[i] == k;</span><br><span class="line">        <span class="keyword">if</span> (m.find(nums[i] - k) != m.end()) res += m[nums[i] - k];</span><br><span class="line">        m[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3307/" target="_blank" rel="noopener">Subarray Sum Equals K</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-22 Subarray Sum Equals K
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-21</title>
    <link href="https://karlszp.github.io/2020/04/21/leetcode-day-21/"/>
    <id>https://karlszp.github.io/2020/04/21/leetcode-day-21/</id>
    <published>2020-04-21T09:23:21.000Z</published>
    <updated>2020-04-21T09:23:42.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-21"><a href="#LeetCode-30-days-Challenge-Day-21" class="headerlink" title="LeetCode 30 days Challenge - Day 21"></a>LeetCode 30 days Challenge - Day 21</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Leftmost-Column-with-at-Least-a-One"><a href="#Leftmost-Column-with-at-Least-a-One" class="headerlink" title="Leftmost Column with at Least a One"></a>Leftmost Column with at Least a One</h2><p><em>(This problem is an <strong>interactive problem</strong>.)</em></p><p>A binary matrix means that all elements are <code>0</code> or <code>1</code>. For each <strong>individual</strong> row of the matrix, this row is sorted in non-decreasing order.</p><p>Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a <code>1</code> in it. If such index doesn’t exist, return <code>-1</code>.</p><p><strong>You can’t access the Binary Matrix directly.</strong> You may only access the matrix using a <code>BinaryMatrix</code> interface:</p><ul><li><code>BinaryMatrix.get(x, y)</code> returns the element of the matrix at index <code>(x, y)</code> (0-indexed).</li><li><code>BinaryMatrix.dimensions()</code> returns a list of 2 elements <code>[n, m]</code>, which means the matrix is <code>n * m</code>.</li></ul><p>Submissions making more than <code>1000</code> calls to <code>BinaryMatrix.get</code> will be judged <em>Wrong Answer</em>. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p><p>For custom testing purposes you’re given the binary matrix <code>mat</code> as input in the following four examples. You will not have access the binary matrix directly. </p><p><strong>Example 1:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[1,1]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0,0,1],[0,0,1,1],[0,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= mat.length, mat[i].length &lt;= 100</code></li><li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li><li><code>mat[i]</code> is sorted in a non-decreasing way.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：本题的解释较为生涩，简单来说：给定一个n x m的、只含有0或1的数组，找到其中含有1的、最左边的列，该数组每一行按照非降序排列。</p><p>解法：</p><p>暴力搜索复杂度是O(nm)，采用二分降到O(nlogm)。</p><p>具体实现思想如下：</p><ol><li>对每一列，使用变量flag（初始化为0）检测是否含有1：flag大于0则含有，反之不含有。</li><li>对每一行，使用二分搜索，且注意每一行中1总在0的右边出现（题示：每一行非降序排列），为找到<code>最左边</code>的列，遵守以下规则：<ol><li>若mid列含有1，记录之，并且尝试寻找更左边的一列：<code>r = mid</code>；</li><li>若mid列不含有1，则尝试寻找更右边的一列：<code>l = mid + 1</code>；</li></ol></li></ol><p>最后，当<code>l == r</code>退出时，检测res是否为-1（初始化值），若仍为-1，则需要对第 <code>l</code> 列再次进行检测。</p><p>注：解释一下为什么只有为-1时需要检测：</p><ol><li>退出时若res已经不为-1，则是通过规则1达到退出条件，说明正在尝试寻找“更左边”的一列，然而此时已经不存在更左边的合格列了，则无需检测。</li><li>若仍为-1，说明正在通过规则2尝试寻找合法列，退出循环后需要进行检测看看最后是否找到。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = binaryMatrix.dimensions()[<span class="number">0</span>], m = binaryMatrix.dimensions()[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>, res = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, mid);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;res = mid; r = mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flag += binaryMatrix.get(i, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? l : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306/" target="_blank" rel="noopener">Leftmost Column with at Least a One</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-21 Leftmost Column with at Least a One
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-20</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-20/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-20/</id>
    <published>2020-04-20T08:45:24.000Z</published>
    <updated>2020-04-20T08:45:55.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-20"><a href="#LeetCode-30-days-Challenge-Day-20" class="headerlink" title="LeetCode 30 days Challenge - Day 20"></a>LeetCode 30 days Challenge - Day 20</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Construct Binary Search Tree from Preorder Traversal"></a>Construct Binary Search Tree from Preorder Traversal</h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p><p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt;</code> <code>node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt;</code> <code>node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt="img" style="zoom:50%;" /><p><strong>Note:</strong> </p><ol><li><code>1 &lt;= preorder.length &lt;= 100</code></li><li>The values of <code>preorder</code> are distinct.</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个二叉搜索树的前序遍历序列，要求还原该二叉树。</p><p>解法：</p><p>本题只要了解：</p><ol><li>二叉搜索树的特性：<ol><li>对任意结点，其结点值永远满足（如果存在）：<code>左儿子 &lt; 根 &lt; 右儿子</code>；</li><li>由此推出，<code>左子树任意值 &lt; 根 &lt; 右子树任意值</code>；</li></ol></li><li>前序遍历：<code>根 -&gt; 左 -&gt; 右</code> 顺序进行遍历。</li></ol><p>由此，总结还原的思想是：</p><ol><li>对当前序列，第一个值是根结点，剩余序列中，比第一个值小的是左子树，剩余为右子树。</li><li>递归操作即可，当序列只有一个元素时，直接返回。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r &amp;&amp; preorder[i] &lt; root-&gt;val) i++;</span><br><span class="line">    root-&gt;left = (i == l + <span class="number">1</span>) ? <span class="literal">NULL</span> : build(preorder, l + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = (i &gt; r) ? <span class="literal">NULL</span> : build(preorder, i, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3305/" target="_blank" rel="noopener">Construct Binary Search Tree from Preorder Traversal</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-20 Construct Binary Search Tree from Preorder Traversal
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-19</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-19/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-19/</id>
    <published>2020-04-20T03:22:53.000Z</published>
    <updated>2020-04-20T03:39:18.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-19"><a href="#LeetCode-30-days-Challenge-Day-19" class="headerlink" title="LeetCode 30 days Challenge - Day 19"></a>LeetCode 30 days Challenge - Day 19</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个经过“旋转”的升序排列数组，在其中查找<code>target</code>，若不存在返回<code>-1</code>。</p><p>解法：</p><p>本题有多种解法，作者选用的是一种比较直观的方法，其他更为“tricky”的题解可参考原题讨论区。</p><p>思路大体上分为两步：</p><ol><li>二分搜索，找到原升序排列数组第一个元素在给定数组中的位置<code>sep</code>。</li><li>通过映射，将给定数组的元素位置“映射”到实际位置：<code>true_pos = (pos + sep) % nums.size()</code></li><li>在此基础上，进行二分搜索。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, sep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    sep = l;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mapped_mid = (mid + sep) % nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums[mapped_mid] == target) <span class="keyword">return</span> mapped_mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mapped_mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3304/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-19 Search in Rotated Sorted Array
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-18</title>
    <link href="https://karlszp.github.io/2020/04/20/leetcode-day-18/"/>
    <id>https://karlszp.github.io/2020/04/20/leetcode-day-18/</id>
    <published>2020-04-20T03:22:51.000Z</published>
    <updated>2020-04-20T03:23:10.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-18"><a href="#LeetCode-30-days-Challenge-Day-18" class="headerlink" title="LeetCode 30 days Challenge - Day 18"></a>LeetCode 30 days Challenge - Day 18</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h2><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个m x n的数组，每个元素代表该位置的路径代价，只能向下或向右移动，计算从左上角到右下角的最小代价路径。</p><p>解法：</p><p>非常简单的动态规划思想：</p><ol><li>对每个位置，只能从上方或左边到来。</li><li>对第一行、第一列的位置，只能从左边、上方到来。</li><li>对其他位置，将路径代价从左到右、从上到下地更新为 <code>该位置代价 + min(上方代价，左边代价)</code> 即可。</li></ol><p>最后，右下角元素的值即为最小代价路径。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid.back().back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3303/" target="_blank" rel="noopener">Minimum Path Sum</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-18 Minimum Path Sum
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-17</title>
    <link href="https://karlszp.github.io/2020/04/17/leetcode-day-17/"/>
    <id>https://karlszp.github.io/2020/04/17/leetcode-day-17/</id>
    <published>2020-04-17T08:28:12.000Z</published>
    <updated>2020-04-17T08:28:38.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-17"><a href="#LeetCode-30-days-Challenge-Day-17" class="headerlink" title="LeetCode 30 days Challenge - Day 17"></a>LeetCode 30 days Challenge - Day 17</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只含有字符<code>0</code>和<code>1</code>的二维数组，其中0代表海洋、1代表陆地，<code>连接在一起</code>的陆地构成一座<code>岛屿</code>，求地图中岛屿的个数。</p><p>解法：</p><p>典型的DFS或BFS问题，本题中可以直接修改grid值，在访问过陆地(1)之后可以将之修改为海洋(0)，无需额外设立一个访问数组。</p><p>具体过程如下：</p><ol><li>新建一个变量nums记录岛屿数。</li><li>遍历整个数组，遇到为<code>陆地</code>的元素时，以该元素位置为起点进行深度优先搜索，确保其所在岛屿所有的陆地都被访问到并且修改为海洋。</li></ol><p>因为每次访问都保证其所在岛屿所有的陆地都被访问到并且修改为海洋，所以遇到新的陆地时将nums加1。</p><p>注：本题所给的grid数组是<code>char 字符型</code>数组！进行判断时候不可以写<code>if (grid[i][j])</code>而要写<code>if (grid[i][j]==&#39;1&#39;)</code>。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;grid.size()<span class="number">-1</span> || y&lt;<span class="number">0</span> || y&gt;grid[<span class="number">0</span>].size()<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[x][y]==<span class="string">'1'</span>) &#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) dfs(x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>], grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                nums++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3302/" target="_blank" rel="noopener">Number of Islands</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-17 Number of Islands
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-16</title>
    <link href="https://karlszp.github.io/2020/04/16/leetcode-day-16/"/>
    <id>https://karlszp.github.io/2020/04/16/leetcode-day-16/</id>
    <published>2020-04-16T09:07:24.000Z</published>
    <updated>2020-04-16T09:07:44.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-16"><a href="#LeetCode-30-days-Challenge-Day-16" class="headerlink" title="LeetCode 30 days Challenge - Day 16"></a>LeetCode 30 days Challenge - Day 16</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Valid-Parenthesis-String"><a href="#Valid-Parenthesis-String" class="headerlink" title="Valid Parenthesis String"></a>Valid Parenthesis String</h2><p>Given a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules:</p><ol><li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li><li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li><li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li><li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string.</li><li>An empty string is also valid.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*)&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*))&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The string size will be in the range [1, 100].</li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个包含左右圆括号以及星号的字符串，其中星号可以视为左右圆括号或者空字符串，判断该字符串是否符合规范。</p><p>解法：</p><p>本题乍一看像栈结构的经典例题，但本题引入了<code>*</code>号的特殊性，带来了一定难度。</p><p>首先考虑，<code>*</code>的引入带来的影响：</p><ol><li>假若视为 <code>(</code>，那么需要一个额外的 <code>)</code> 进行匹配。</li><li>假若视为 <code>)</code>，那么能额外匹配一个位置在其之前的 <code>(</code> 。</li><li>假若视为空，那么没有影响。</li></ol><p>由于一个符合规范的序列，<code>(</code>往往先于<code>)</code>出现，因此可以考虑 <code>*</code> 的不同取值，对需要的 <code>)</code> 数量的影响。</p><p>假设，最少需要min_num个 <code>)</code>，最多需要max_num个 <code>)</code>，问题转化为 <code>*</code> 的不同取值，对上述两个变量的影响：</p><ol><li>遇到 <code>(</code>：min_num、max_num都增加1，这是显然的。</li><li>遇到 <code>)</code>：<ol><li>max_num减少1，这也是显然的；</li><li>min_num也减少1，但不少于0（右括号只能匹配其左边的左括号，如果min_num减少成负数，相当于之后的右括号匹配了之前的左括号，是不符合常理的）。</li></ol></li><li>遇到 <code>*</code>：<ol><li>因为可以看成一个 <code>(</code>，max_num增加1；</li><li>也可以看成一个 <code>)</code>，min_num也减少1，但不少于0（理由同上）。</li><li>看成空串则不会造成影响。</li></ol></li></ol><p>在遍历过程中，若出现max_num小于0的情况，即出现了一个无法匹配的右括号，直接返回 <code>false</code>。</p><p>最后，因为min_num是最少需要的条件，判断min_num是否为0即可。</p><p>注：本题较难理解的是min_num在遍历过程中不能小于0的原因：小于0则相当于某一个左括号之后的右括号匹配了该左括号，是不符合常理的，这两个括号就是这种情况“ )( ”。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_num = <span class="number">0</span>, max_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            min_num++;</span><br><span class="line">            max_num++;                    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num--;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min_num = max(min_num<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            max_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3301/" target="_blank" rel="noopener">Valid Parenthesis String</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-16 Valid Parenthesis String
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-14</title>
    <link href="https://karlszp.github.io/2020/04/14/leetcode-day-14/"/>
    <id>https://karlszp.github.io/2020/04/14/leetcode-day-14/</id>
    <published>2020-04-14T14:47:45.000Z</published>
    <updated>2020-04-14T15:10:26.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-14"><a href="#LeetCode-30-days-Challenge-Day-14" class="headerlink" title="LeetCode 30 days Challenge - Day 14"></a>LeetCode 30 days Challenge - Day 14</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Perform-String-Shifts"><a href="#Perform-String-Shifts" class="headerlink" title="Perform String Shifts"></a>Perform String Shifts</h2><p>You are given a string <code>s</code> containing lowercase English letters, and a matrix <code>shift</code>, where <code>shift[i] = [direction, amount]</code>:</p><ul><li><code>direction</code> can be <code>0</code> (for left shift) or <code>1</code> (for right shift). </li><li><code>amount</code> is the amount by which string <code>s</code> is to be shifted.</li><li>A left shift by 1 means remove the first character of <code>s</code> and append it to the end.</li><li>Similarly, a right shift by 1 means remove the last character of <code>s</code> and add it to the beginning.</li></ul><p>Return the final string after all operations.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, shift &#x3D; [[0,1],[1,2]]</span><br><span class="line">Output: &quot;cab&quot;</span><br><span class="line">Explanation: </span><br><span class="line">[0,1] means shift to left by 1. &quot;abc&quot; -&gt; &quot;bca&quot;</span><br><span class="line">[1,2] means shift to right by 2. &quot;bca&quot; -&gt; &quot;cab&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcdefg&quot;, shift &#x3D; [[1,1],[1,1],[0,2],[1,3]]</span><br><span class="line">Output: &quot;efgabcd&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">[1,1] means shift to right by 1. &quot;abcdefg&quot; -&gt; &quot;gabcdef&quot;</span><br><span class="line">[1,1] means shift to right by 1. &quot;gabcdef&quot; -&gt; &quot;fgabcde&quot;</span><br><span class="line">[0,2] means shift to left by 2. &quot;fgabcde&quot; -&gt; &quot;abcdefg&quot;</span><br><span class="line">[1,3] means shift to right by 3. &quot;abcdefg&quot; -&gt; &quot;efgabcd&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> only contains lower case English letters.</li><li><code>1 &lt;= shift.length &lt;= 100</code></li><li><code>shift[i].length == 2</code></li><li><code>0 &lt;= shift[i][0] &lt;= 1</code></li><li><code>0 &lt;= shift[i][1] &lt;= 100</code></li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个原始字符串以及一个位移指令集合shift，shift数组中，每个元素是一个二元组，依次表示对字符串进行的位移操作方向以及位数，要求返回最后处理完成的字符串。</p><p>解法：</p><p>本题提示中，说明了在限制条件下，直接暴力模拟也能通过，但这肯定不是我们想要的答案，为了尽可能减少“移动”操作，先来分析移动操作的特点：</p><ol><li>方向0：向左移动amount个元素，实际上是将<code>前amount个元素移动到字符串尾部</code>。</li><li>方向1：向右移动amount个元素，实际上是将<code>后amount个元素移动到字符串头部</code>。</li></ol><p>两次方向不同、amount相同的移动，将相互抵消：<code>abcd -0,2-&gt; cdab -1,2-&gt; abcd</code>。</p><p>由此，推断出最便利的做法是，先遍历shift数组，记录最终需要移动的步数（final_amount），具体措施：</p><ol><li>遇到方向0，final_amount减去对应amount；</li><li>遇到方向1，final_amount加上对应amount；</li></ol><p>最后，根据final_amount的正负（注意对长度取模，长度为n的字符串移动n次将恢复原状），依据移动操作的特点进行处理即可。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stringShift</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; shift)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> final_amount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : shift) final_amount += v[<span class="number">0</span>] ? v[<span class="number">1</span>] : -v[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (final_amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        final_amount %= s.length();</span><br><span class="line">        res = s.substr(<span class="number">0</span>, s.length() - final_amount);</span><br><span class="line">        res = s.substr(s.length() - final_amount) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        final_amount = (-final_amount) % s.length();</span><br><span class="line">        res = s.substr(final_amount);</span><br><span class="line">        res += s.substr(<span class="number">0</span>, final_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3299/" target="_blank" rel="noopener">Perform String Shifts</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-14 Perform String Shifts
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-13</title>
    <link href="https://karlszp.github.io/2020/04/13/leetcode-day-13/"/>
    <id>https://karlszp.github.io/2020/04/13/leetcode-day-13/</id>
    <published>2020-04-13T08:04:47.000Z</published>
    <updated>2020-04-13T08:05:31.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-13"><a href="#LeetCode-30-days-Challenge-Day-13" class="headerlink" title="LeetCode 30 days Challenge - Day 13"></a>LeetCode 30 days Challenge - Day 13</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a>Contiguous Array</h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个只包含0或1的数组，求满足条件（子数组中0和1数量相等）的最长连续子数组的长度。</p><p>解法：</p><p>本题关键是遍历数组，确保不漏掉符合条件的子数组，并更新最大长度。</p><p>这里为了减少空间复杂度，使用哈希结构建立count（初始为0，遇0减1，遇1加1）到pos（count第一次出现的位置）的映射：</p><ol><li>初始化res为最大长度，count为当前1和0的个数差，负数表示0比1多。</li><li>建立映射，初始化<code>m[0] = -1</code>的意义是：无论第一个元素是0还是1，count都将变为非0，因此，count=0首次出现的位置实际上是<code>-1</code>处（不存在，只是虚拟出一个位置，以保证当最长子数组包含第一个元素的时候，能正确计算长度）。</li><li>在遍历过程中：<ol><li>当<code>m.find(count) == m.end()</code>即新的count值首次出现，记录其位置。</li><li>反之，更新res为较大值。</li></ol></li></ol><p>以下提供参考图片供读者理解：</p><p><img src="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/Figures/535_Contiguous_Array.PNG" alt=""></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        count += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.find(count) == m.end()) m[count] = i;</span><br><span class="line">        <span class="keyword">else</span> res = max(res, i - m[count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3298/" target="_blank" rel="noopener">Contiguous Array</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-13 Contiguous Array
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-12</title>
    <link href="https://karlszp.github.io/2020/04/12/leetcode-day-12/"/>
    <id>https://karlszp.github.io/2020/04/12/leetcode-day-12/</id>
    <published>2020-04-12T08:33:12.000Z</published>
    <updated>2020-04-12T08:33:40.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-12"><a href="#LeetCode-30-days-Challenge-Day-12" class="headerlink" title="LeetCode 30 days Challenge - Day 12"></a>LeetCode 30 days Challenge - Day 12</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Last-Stone-Weight"><a href="#Last-Stone-Weight" class="headerlink" title="Last Stone Weight"></a>Last Stone Weight</h2><p>We have a collection of stones, each stone has a positive integer weight.</p><p>Each turn, we choose the two <strong>heaviest</strong> stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p><ul><li>If <code>x == y</code>, both stones are totally destroyed;</li><li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li></ul><p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ol><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个整形数组，每个值代表一颗石子的质量。每次选取质量最大的两颗石子（如果存在至少两颗石子），若两颗石子质量相等，则进行下一次选取；否则，将一颗质量为它们的质量差的石子加入数组中。</p><p>解法：</p><p>简单进行模拟，重点注意每次需要选取质量最大的两颗，而且新加入石子后影响原有顺序，考虑使用大顶堆进行存储，作者采用的是STL中大顶堆实现的优先队列<code>&lt;priority_queue&gt;</code>。</p><p>确定了储存结构，模拟操作如下：</p><ol><li>首先遍历数组，将“石子”加入优先队列。</li><li>根据题目要求，当剩余石子为1颗或0颗时，结束循环，否则：<ol><li>取队首元素，赋值给y，并将之出队；</li><li>再次取队首元素，赋值给x，并将之出队；</li><li>由于是优先队列，y &gt;= x，因此只需比较x是否与y相等：<ol><li>相等：不进行操作，相当于两颗石子抵消了。</li><li>不相等：将质量差值y-x加入优先队列。</li></ol></li></ol></li><li>最后判断队列是否为空即可，</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : stones) pq.push(i);</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">int</span> x = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (x != y) pq.push(y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.empty() ? <span class="number">0</span> : pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3297/" target="_blank" rel="noopener">Last Stone Weight</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-12 Last Stone Weight
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-11</title>
    <link href="https://karlszp.github.io/2020/04/11/leetcode-day-11/"/>
    <id>https://karlszp.github.io/2020/04/11/leetcode-day-11/</id>
    <published>2020-04-11T08:36:20.000Z</published>
    <updated>2020-04-11T08:47:08.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-11"><a href="#LeetCode-30-days-Challenge-Day-11" class="headerlink" title="LeetCode 30 days Challenge - Day 11"></a>LeetCode 30 days Challenge - Day 11</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一棵二叉树，要求找到它的直径。二叉树直径定义为其中距离最远的两个节点之间的距离。</p><p>解法：</p><p>由题，我们知道直径不一定经过当前树的根结点。</p><p>因此，对以当前结点为根结点的（子）树，根据是否经过其根结点，可以分为两种情况，递归思想如下：</p><ol><li>对于非空结点，计算：<ol><li>左子树的深度 + 右子树的深度 = <strong>经过</strong>当前结点的最长距离；</li><li>左子树的直径（递归，不经过根结点）；</li><li>右子树的直径（递归，不经过根结点）；</li></ol></li><li>对以上三值，取最大值即为以当前结点为根的二叉树的直径。</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(getdepth(root-&gt;left), getdepth(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = getdepth(root-&gt;left) + getdepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> max(cur, max(diameterOfBinaryTree(root-&gt;left), diameterOfBinaryTree(root-&gt;right)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3293/" target="_blank" rel="noopener">Diameter of Binary Tree</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-11 Diameter of Binary Tree
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-10</title>
    <link href="https://karlszp.github.io/2020/04/10/leetcode-day-10/"/>
    <id>https://karlszp.github.io/2020/04/10/leetcode-day-10/</id>
    <published>2020-04-10T08:51:52.000Z</published>
    <updated>2020-04-10T08:52:46.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-10"><a href="#LeetCode-30-days-Challenge-Day-10" class="headerlink" title="LeetCode 30 days Challenge - Day 10"></a>LeetCode 30 days Challenge - Day 10</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：实现一个最小栈，包括压栈、退栈、返回最小值等函数。</p><p>解法：</p><p>最小栈结构为了记录最小值，需要多使用一个栈来记录最小值。</p><p>接下来，讨论各个方法如何实现：</p><ol><li><p>push() 压栈：</p><ol><li><p>首先，无论如何将数据压入数据栈；</p></li><li><p>接着进行判断，若最小栈栈顶元素大于或等于压入的数据，将该数据压入最小栈。</p><p>（此处注意，等于的情况也要压栈，这样才能避免退栈操作在多个最小值删除。）</p></li></ol></li><li><p>pop() 出栈：</p><ol><li><p>首先，若最小栈栈顶元素等于当前栈顶元素，将最小栈栈顶元素弹出。</p><p>（此处注意push操作中第二步的注释。）</p></li><li><p>将栈顶元素出栈。</p></li></ol></li><li><p>top() 访问栈顶元素：调用vector结构的back()方法。</p></li><li><p>getMin() 访问最小值：调用stack结构的top()方法。</p></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ministack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        ministack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ministack.top()) ministack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.back() == ministack.top()) ministack.pop();</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ministack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3292/" target="_blank" rel="noopener">Min Stack</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-10 Min Stack
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-9</title>
    <link href="https://karlszp.github.io/2020/04/10/leetcode-day-9/"/>
    <id>https://karlszp.github.io/2020/04/10/leetcode-day-9/</id>
    <published>2020-04-10T04:25:30.000Z</published>
    <updated>2020-04-10T04:34:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-9"><a href="#LeetCode-30-days-Challenge-Day-9" class="headerlink" title="LeetCode 30 days Challenge - Day 9"></a>LeetCode 30 days Challenge - Day 9</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Backspace-String-Compare"><a href="#Backspace-String-Compare" class="headerlink" title="Backspace String Compare"></a>Backspace String Compare</h2><p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ol><li><code>1 &lt;= S.length &lt;= 200</code></li><li><code>1 &lt;= T.length &lt;= 200</code></li><li><code>S</code> and <code>T</code> only contain lowercase letters and <code>&#39;#&#39;</code> characters.</li></ol><p><strong>Follow up:</strong></p><ul><li>Can you solve it in <code>O(N)</code> time and <code>O(1)</code> space?</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定两个字符串，其中“#”号表示一个退格，要求判断处理完退格操作后两个字符串是否相同。</p><p>解法：</p><p>本题是栈结构的经典应用，以下分析模拟操作的原则：</p><ol><li>遍历字符串，遇到不为退格“#”的字符，压栈。</li><li>遇到退格“#”时：<ol><li>若栈为空，忽略（空字符串怎么进行退格依然为空）。</li><li>反之，将栈顶元素退栈（相当于退格当前字符串的最后一个字符）。</li></ol></li><li>对两个字符串处理完成后，依次退栈比较：<ol><li>遇到不相同的字符，则返回<code>false</code>。</li><li>比较到栈空，返回<code>true</code>。</li></ol></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !s.empty()) s.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) s.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !t.empty()) t.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) t.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() &amp;&amp; !t.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() != t.top()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop(); t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s.empty() &amp;&amp; t.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3291/" target="_blank" rel="noopener">Backspace String Compare</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-9 Backspace String Compare
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-day-8</title>
    <link href="https://karlszp.github.io/2020/04/08/leetcode-day-8/"/>
    <id>https://karlszp.github.io/2020/04/08/leetcode-day-8/</id>
    <published>2020-04-08T13:24:26.000Z</published>
    <updated>2020-04-08T13:33:33.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-30-days-Challenge-Day-8"><a href="#LeetCode-30-days-Challenge-Day-8" class="headerlink" title="LeetCode 30 days Challenge - Day 8"></a>LeetCode 30 days Challenge - Day 8</h1><p>本系列将对LeetCode新推出的30天算法挑战进行总结记录，旨在记录学习成果、方便未来查阅，同时望为广大网友提供帮助。</p><hr><h2 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a>Middle of the Linked List</h2><p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p><p>If there are two middle nodes, return the second middle node.</p><p> <strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure><p> <strong>Note:</strong></p><ul><li>The number of nodes in the given list will be between <code>1</code> and <code>100</code>.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求分析：给定一个非空链表的头指针，返回这个链表在中间位置的结点。</p><p>解法：</p><p>典型例题，常常使用快慢指针来定位链表中部。</p><p>快指针一次步进2个结点，慢指针一次步进1个结点。当快指针到达末尾，慢指针正好到达链表中部。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, * slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>传送门：<a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3290/" target="_blank" rel="noopener">Middle of the Linked List</a></p><p>Karl</p>]]></content>
    
    <summary type="html">
    
      Day-8 Middle of the Linked List
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://KARLSZP.github.io/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://KARLSZP.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
